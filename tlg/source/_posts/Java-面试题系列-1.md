title: Java 面试题系列 1
author: 知识铺
date: 2020-04-06 20:17:19
tags:
---
 
## Java 面试题系列一


## 1\. 简介

本文包含一些有关核心 Java 的最重要工作面试问题的答案。其中一些问题的答案可能并不明显，因此本文将有助于澄清问题。

## 2\. 初学者的核心Java语言问题

### 问题 1.数据是通过引用传递的还是按 Java 中的值传递的？

虽然这个问题的答案很简单，但这个问题对初学者来说可能令人困惑。首先，让我们澄清问题所在：

1.  **传递值 –**这意味着我们将**对象的副本**作为参数传递到方法中。
2.  **通过引用传递 –**这意味着我们将**对对象的引用**作为参数传递到方法中。

为了回答这个问题，我们必须分析两个案例。它们表示两种类型的数据，我们可以传递给方法：基元和对象。

当我们将基元传递给方法时，其值将复制到新变量中。当涉及到对象时，引用的值将复制到新变量中。**因此，我们可以说Java是一种严格的_逐种语言_。**

我们可以在我们的一篇文章中更多地了解这一点：在[Java中传递值作为参数传递机制](https://zshipu.com/t?url=https://www.baeldung.com/java-pass-by-value-or-pass-by-reference)。

### 问题 2.导入和静态导入之间的区别是什么？

我们可以使用常规导入导入特定类或不同包中定义的所有类：

```
 
 import

 java.util.ArrayList;

 //specific class


 
 import

 java.util.*;

 //all classes in util package

```

我们还可以使用它们导入封闭类的公共嵌套类：


```
 
 import

 com.baeldung.A.*

```
 

但是，我们应该知道上面的导入不会导入类_A_本身。

**还有一些静态导入，使我们能够导入静态成员或嵌套类：**


 ```
 import

 static

 java.util.Collections.EMPTY_LIST;

```
 

其效果是，我们可以使用静态变量EMPTY_LIST而不预处理完全限定的类名称，即好像它是在当前类中声明的一样。

### 问题 3.哪些访问修改器在 Java 中可用，它们的目的是什么？

_Java_中有四个访问修改器：

1.  _私人_
2.  _默认值_（包）
3.  _保护_
4.  _公共_

**_专用_修饰符确保类成员在类外部无法访问。**它可以应用于方法、属性、构造函数、嵌套类，但不能应用于顶级类本身。

与_私有_修改器不同，我们可以将_默认_修改器应用于所有类型的类成员和类本身。我们可以通过根本不添加任何访问修改器来应用_默认_可见性。**如果我们使用_默认_可见性，我们的类或其成员将只能在类的包内访问。**我们应该记住，默认访问修改器与_默认_关键字没有任何共同之处。

与_默认_修改器类似，一个包中的所有类都可以访问_受保护的_成员。**此外，_受保护的_修改器允许子类访问超级类的受保护成员，即使它们不在同一个包中也是如此。**我们不能将此访问修改器应用于类，而只能应用于类成员。

_公共_修改符可以与类关键字和所有类成员一起使用。**它使类和类成员在所有包和所有类中都可以访问。**

我们可以在[Java 访问修改器](https://zshipu.com/t?url=https://www.baeldung.com/java-access-modifiers)一文中了解更多信息。

### 问题 4.哪些其他修改器在 Java 中可用，它们的目的是什么？

Java 中还有五个其他修改器：

*   _静态_
*   _最后_
*   _抽象_
*   _同步_
*   _挥发 性_

这些不能控制可见性。

首先，我们可以将_静态_关键字应用于字段和方法。**静态字段或方法是类成员，而非静态字段是对象成员**。类成员不需要调用任何实例。它们使用类名称而不是对象引用名称调用。[本文](https://zshipu.com/t?url=https://www.baeldung.com/java-static)详细介绍了_静态_关键字。

然后，我们有_最后_关键字。我们可以将其用于字段、方法和类。**当_在_字段上使用 final 时，这意味着无法更改字段引用。**因此，无法将其重新分配给其他对象。**当_最终_应用于类或方法时，它向我们保证该类或方法不能扩展或重写。**[本文](https://zshipu.com/t?url=https://www.baeldung.com/java-final)将更详细地解释_最终_关键字。

下一个关键字是_抽象_的。这可以描述类和方法。**当类是_抽象_的时，它们无法实例化。**相反，它们被分类。当方法是_抽象_的时，它们没有实现，可以在子类中重写它们。

_同步_关键字可能是最先进的。我们可以将其与实例以及静态方法和代码块一起使用。**当我们使用此关键字时，我们让 Java 使用监视器锁来提供给定代码片段的同步。**有关_同步_的详细信息，请参阅[本文](https://zshipu.com/t?url=https://www.baeldung.com/java-synchronized)。

我们要讨论的最后一个关键字是_不稳定的_。我们只能将其与实例字段一起使用。**它声明字段值必须读取和写入主内存 - 绕过 CPU 缓存。**可变变量的所有读取和写入都是原子的。[本文](https://zshipu.com/t?url=https://www.baeldung.com/java-volatile)详细介绍了易失性关键字。

### 问题 5.JDK、JRE 和 JVM 之间的区别是什么？

_JDK_代表_Java开发工具包_，这是开发人员在Java中编写应用程序所需的一组工具。JDK 环境有三种类型：

*   标准版 + 开发套件，用于创建便携式桌面或服务器应用程序
*   企业版 – 支持分布式计算或 Web 服务的标准版扩展
*   嵌入式和移动应用的微型版和开发平台

JDK 中包含了大量的工具，**可帮助程序员编写、调试或维护应用程序**。最流行的是编译器 （_javac_）， 解释器 （_java_）， 一个归档器 （_jar_） 和文档生成器 （_javadoc_）.

_JRE_是一个_Java运行时环境_。它是 JDK 的一部分，**但它包含运行 Java 应用程序的最小功能**。它由_Java虚拟机_、核心类和支持文件组成。例如，它没有任何编译器。

_JVM_是_Java虚拟机_的首字母缩写词，它是一种能够运行编译为字节码的程序的虚拟机。JVM 规范对此进行了描述，因为确保不同实现之间的互操作性非常重要。**JVM最重要的功能是使用户能够将同一Java应用程序部署到不同的操作系统和环境，而不必担心下面是什么**。

有关详细信息，我们来查看[JVM、JRE 和 JDK](https://zshipu.com/t?url=https://www.baeldung.com/jvm-vs-jre-vs-jdk)文章之间的差异。

### 问题 6.堆栈和堆之间的区别是什么？

内存有两个部分，其中 JVM 存储所有变量和对象。第一个是_堆栈_，第二个是_堆_。

**_堆栈_是 JVM 为本地变量和其他数据保留块的地方**。堆栈是一个_LIFO（_最后一个在先出）结构。这意味着，每当调用方法时，都会为局部变量和对象引用保留一个新块。每个新方法调用都保留下一个块。当方法完成执行时，块以相反的方式释放它们。

每个新线程都有自己的堆栈。

我们应该知道，堆栈的内存空间比堆少得多。当堆栈已满时，JVM 将抛出_堆栈溢出错误_。当有一个坏的递归调用，并且递归太深时，它可能发生。

**每个新对象都是在 Java _h__eap_上创建的，该对象用于动态分配**。有一个_g__arbage收集器_，负责删除未使用的对象，这些对象分为年轻（苗圃）和旧空间。对堆的内存访问比对堆栈的访问慢。堆已满时，JVM 会引发_内存错误_。

我们可以在 Java 文章中的[堆栈内存和堆空间中找到](https://zshipu.com/t?url=https://www.baeldung.com/java-stack-heap)更多详细信息。

### 问题 7._可比_接口和_比较接口_之间的区别是什么？

有时，当我们编写一个新类时，我们希望能够比较该类的对象。当我们想要使用已排序的集合时，它特别有用。我们可以有两种方法可以做到这一点：使用_可比较_接口或_比较器_接口。

首先，让我们来看看_可比_接口：

 ```
 public

 interface

 Comparable<T> {


 
 int

 compareTo(T var1);


 
 }


 ```

我们应该通过要排序的对象的类实现该接口。

它有_比较To（）_方法，并返回一个整数。它可以返回三个值：-1、0 和 1，这意味着此对象小于、等于或大于比较的对象。

**值得一提的是，重写_的比较T0（）_方法应该与_等（）_法一致。**

另一方面，我们可以使用_比较器_接口。它可以传递到_集合_接口的_sort（）_方法或实例化排序集合时。这就是为什么它主要用于创建一次性排序策略。

**此外，当我们使用不实现可比较接口的第三方类时，它也是有用的。**

与_比较To（）_方法一样，重写_的比较（）_方法应与_等值（）_方法一致，但它们可以选择允许与 null 进行比较。

有关详细信息，请访问[Java 中的比较器和可比性](https://zshipu.com/t?url=https://www.baeldung.com/java-comparator-comparable)文章。

### 问题 8.什么是_空隙_类型，我们何时使用它？

每次在 Java 中编写方法时，它必须具有返回类型。如果我们想要该方法返回不返回值，我们可以使用_void_关键字。

我们也应该知道，有一个_虚空_类。它是一个占位符类，可用于，例如，在使用泛型时。_虚空_类既不能实例化，也不能扩展。

### 问题 9.对象类的方法是什么，它们的作用是什么？

了解_Object_类包含哪些方法以及它们的工作原理非常重要。当我们想要重写这些方法时，它也非常有用：

*   _克隆（）_ = 返回此对象的副本
*   _等于（）_ = 当此对象等于作为参数传递的对象时返回_true_
*   _finalize（）_ = 垃圾回收器在清理内存时调用此方法
*   _getClass（）_ = 返回此对象的运行时类
*   _哈希码（）_ = 返回此对象的哈希代码。**我们应该知道，它应该与_等（）_法一致**
*   _通知（）_ - 向等待对象的监视器的单个线程发送通知
*   _通知 All（）_ = 向所有等待对象监视器的线程发送通知
*   _到String（）_ = 返回此对象的字符串表示形式
*   _wait（）_ = 此方法有三个重载版本。它强制当前线程等待指定的时间量，直到另一个线程调用_通知（）_或_通知此对象上的 All（）。_

### 问题 10.什么是枚举和我们如何使用它？

_Enum_是一种类类型，它允许开发人员指定一组预定义的常量值。要创建这样的类，我们必须使用_枚举_关键字。让我们想象一下一周中的天数：


```
 
 public

 enum

 Day {


 
 SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY


 
 }


```

为了迭代所有常量，我们可以使用静态_值（）_方法。此外，枚举使我们能够定义成员，如属性和方法，如常规类。

**虽然它是一种特殊的类，但我们不能对它进行子类。**但是，枚举可以实现接口。

_枚举_的另一个有趣的优点是，它们是线程安全的，因此它们被普遍用作单例。

我们可以[在我们的指南](https://zshipu.com/t?url=https://www.baeldung.com/a-guide-to-java-enums)中找到更多关于枚举。

### 问题 11.**什么是**JAR？

_JAR_是_Java存档_的快捷方式。它是使用 ZIP 文件格式打包的存档文件。我们可以用它来包括应用程序所需的类文件和辅助资源。它具有许多功能：

*   **安全性 –**我们可以对 JAR 文件进行数字签名
*   **压缩 –**在使用 JAR 时，我们可以压缩文件以高效存储
*   **可移植性 –**我们可以跨多个平台使用相同的 JAR 文件
*   **版本控制 |**JAR 文件可以保存有关其包含的文件的元数据
*   **密封 –**我们可以在 JAR 文件中密封包裹。这意味着一个包中的所有类都必须包含在相同的 JAR 文件中
*   **扩展名 –**我们可以使用 JAR 文件格式来打包现有软件的模块或扩展名

### 十二 题。**什么是**_空指针异常_？

_空指针异常_可能是 Java 世界中最常见的异常。这是一个未检查的异常，因此扩展_了运行时例外_。我们不应该试图处理它。

当我们尝试访问变量或调用 null 引用的方法时引发此异常，例如：

*   调用空引用的方法
*   设置或获取空引用的字段
*   检查空数组引用的长度
*   设置或获取空数组引用的项
*   投掷_空_

### 问题 13.Java 中的两种强制转换类型是什么？强制转换时可能会引发哪个异常？我们如何避免它？

我们可以在 Java 中区分两种类型的强制转换。**我们可以进行向上转换，该预测将对象强制转换为超级类型或下播对象，后者将对象强制转换到子类型。**

_上播_非常简单，因为我们总能做到这一点。例如，我们可以将_字符串_实例向上转换为_对象_类型：


```
 
 Object str =

 "string"
 ;

```
 

或者，我们可以_降低_变量。它不像上播那样安全，因为它涉及类型检查。如果我们错误地强制转换对象，JVM 将在运行时引发_ClassCastExcption。_**幸运的是，我们可以使用_关键字的实例_来防止无效的强制转换：**

 

 ```
 Object o =

 "string"
 ;


 
 String str = (String) o;

 // it's ok


 
 Object o2 =

 new

 Object();


 
 String str2 = (String) o2;

 // ClassCastException will be thrown


 
 if

 (o2

 instanceof

 String) {

 // returns false


 
 String str3 = (String) o2;


 
 }

```
 

我们可以在本文中了解有关类型转换的更多[详细信息](https://zshipu.com/t?url=https://www.baeldung.com/java-type-casting)。

## 3\. 面向高级程序员的核心Java语言问题

### 问题 1.为什么字符串是一个不可改变的类？

我们应该知道_，JVM_对待_String_对象的方式与其他对象不同。一个区别是_String_对象是不可变的。**这意味着，一旦我们创建了它们，我们就无法更改它们。**他们这样做的原因有几个：

1.  它们存储在_字符串池_中，字符串池是堆内存的特殊部分。它负责节省大量空间。
2.  _String_类的不变性可确保其哈希代码不会更改。**因此，_字符串_可以有效地用作哈希集合中的键。**我们可以确信，我们不会覆盖任何数据，因为哈希代码的变化。
3.  它们可以安全地跨多个线程使用。**没有线程可以更改_String_对象的值，因此我们免费获得线程安全性。**
4.  字符串是不可改变的，以避免严重的安全问题。敏感数据（如密码）可能会由不可靠的源或其他线程更改。

我们可以在本文中了解有关字符串的不可变性的更多[。](https://zshipu.com/t?url=https://www.baeldung.com/java-string-immutable)

### 问题 2.动态绑定和静态绑定之间的区别是什么？

Java 中的绑定是一个将方法调用与正确的方法体关联的过程。我们可以区分Java中的两种类型的绑定：静态绑定和动态绑定。

**静态绑定和动态绑定之间的主要区别是静态绑定发生在编译时，在运行时发生动态绑定。**

_静态绑定_使用类信息进行绑定。它负责_解析私有或__静态_和_最终_方法和变量的类成员。此外，静态绑定绑定重载方法。

另一方面，_动态绑定_使用对象信息来解决绑定。这就是为什么它负责解决虚拟和重写的方法。

### 问题 3.什么是 JIT？

_JIT_代表"及时"。它是 JRE 的一个组件，在运行时运行并提高应用程序的性能。**具体来说，它是一个编译器，在程序启动后运行。**

这与常规 Java 编译器不同，后者早在应用程序启动之前就编译了代码。JIT可以以不同的方式加快应用程序的速度。

例如，JIT 编译器负责动态将字节码编译为本机指令，以提高性能。此外，它可以优化代码到目标CPU和操作系统。

此外，它还可以访问许多运行时统计信息，这些统计信息可用于重新编译以实现最佳性能。这样，它还可以执行一些全局代码优化或重新排列代码，以更好的缓存利用率。

### 问题 4.什么是 Java 中的反射？

反射是Java中一个非常强大的机制。反射是一种Java语言机制，它使程序员能够在运行时检查或修改程序的内部状态（属性、方法、类等）。java.lang.反射包提供使用反射所需的所有组件。

使用此功能时，我们可以访问类定义中包含的所有可能的字段、方法、构造函数。无论它们的访问修改器如何，我们都可以访问它们。这意味着，例如，我们能够访问私人成员。为此，我们不必知道他们的名字。我们要做的就是使用_类_的一些静态方法。

值得了解的是，可以通过反射限制访问。为此，我们可以使用 Java 安全管理器和 Java 安全策略文件。它们允许我们向类授予权限。

在使用 Java 9 以来的模块时，我们应该知道，默认情况下，我们无法使用从另一个模块导入的类的反射。为了允许其他类使用反射来访问包的私有成员，我们必须授予"反射"权限。

[本文](https://zshipu.com/t?url=https://www.baeldung.com/java-reflection)更深入地介绍了 Java 反射。

### 问题 5.**什么是类**加载器？

_类加载器_是 Java 中最重要的组件之一。这是JRE的一部分。

简而言之，_类加载器_负责将类加载到 JVM 中。我们可以区分三种类型的类加载器：

*   **引导类加载器 -**它加载核心Java类。它们位于_<JAVA_HOME>/jre/lib_目录中
*   **扩展类加载器 -**它加载位于_<JAVA_HOME>/jre/lib/ext_或_java.ext.dirs_属性定义的路径中的类
*   **系统类加载器 –**它在应用程序的类路径上加载类

类加载器"按需"加载类。这意味着类在程序调用后加载。此外，类加载器只能加载具有给定名称的类一次。但是，如果同一类由两个不同的类加载程序加载，则这些类在相等性检查中失败。

Java 文章中的[类加载器中](https://zshipu.com/t?url=https://www.baeldung.com/java-classloaders)有关类加载器的详细信息。

### 问题 6.静态类加载和动态类加载之间的区别是什么？

静态类加载发生在我们在编译时有源类可用时。我们可以通过_使用新_关键字创建对象实例来使用它。

动态类加载是指在编译时无法提供类定义的情况。然而，我们可以在运行时这样做。要创建类的实例，我们必须使用_class.forName（）_方法：


```
Class.forName(
"oracle.jdbc.driver.OracleDriver"
)
```

### 问题 7._可序列化_接口的目的是什么？

**我们可以使用_可序列化_接口，使用 Java 的序列化 API 实现类的序列化。**序列化是一种将对象状态保存为字节序列的机制，而反序列化是从字节序列中还原对象状态的机制。序列化输出保存对象的状态和有关对象类型和字段类型的一些元数据。

我们应该知道，可序列化类的子类型也是可序列化的。但是，如果我们想要使类具有序列化，但其超类型是不可序列化的，我们必须执行两项操作：

*   实现_可序列化_接口
*   确保超类中没有参数构造函数

我们可以在我们的[一篇文章中](https://zshipu.com/t?url=https://www.baeldung.com/java-serialization)阅读更多关于序列化的文章。

### 问题 8.Java 中是否有析构函数？

在 Java 中，垃圾回收器会自动删除未使用的对象以释放内存。开发人员无需标记对象以进行删除，这很容易出错。**因此，明智的Java没有可用的析构函数。**

如果对象持有打开的套接字、打开的文件或数据库连接，**则垃圾回收器无法回收这些资源**。我们可以以_接近_的方法释放资源，并使用_尝试-finally_语法在Java 7之前调用该方法，例如I/O类_FileInputStream_和_FileOutputStream。_**从Java 7开始，我们可以实现接口_自动可连接，_并使用[_尝试资源_语句](https://zshipu.com/t?url=https://www.baeldung.com/java-try-with-resources)编写更短、更简洁的代码**。但是，API用户可能忘记调用_关闭_方法，因此_最终_方法和_清理器_类应运而生。"**但请注意，它们不等同于析构函数。**

**它不能保证_最终确定_方法和_清洁_类将迅速运行。**他们甚至没有机会在 JVM 退出之前运行。尽管我们可以调用_System.run Final 化_来建议 JVM 运行待定_任何对象的最终_方法，但它仍然是非确定性的。

此外，_最终_方法可能会导致性能问题、死锁等。我们可以通过查看我们的文章之一找到更多信息[：Java 中最终方法指南](https://zshipu.com/t?url=https://www.baeldung.com/java-finalize)。

**从 Java 9**开始，由于它的缺点，添加了**_Cleaner_类以替换_最终_方法**。因此，我们可以更好地控制执行清洁操作的螺纹。

但是java规范指出了在_System.exit_期间清理者的行为是特定于实现的，Java 不保证是否调用清理操作。