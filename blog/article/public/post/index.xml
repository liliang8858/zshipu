<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 知识铺</title>
    <link>https://blog.zshipu.com/article/post/</link>
    <description>Recent content in Posts on 知识铺</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>&lt;a class=&#34;Footer-item&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; href=&#34;http://beian.miit.gov.cn&#34;&gt;浙 ICP 备19032823号-1&lt;/a&gt; |&lt;a class=&#34;Footer-item&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; href=&#34;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602010431&#34;&gt;&lt;img src=&#34;https://zshipu.com/img/ghs.png&#34;&gt;浙公网安备 33010602010431号&lt;/a&gt; | 知识铺 2019.</copyright>
    <lastBuildDate>Mon, 11 Nov 2019 22:27:22 +0800</lastBuildDate>
    
	<atom:link href="https://blog.zshipu.com/article/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker 从入门到实践 - Docker 网络实现</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/network/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:22 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/network/</guid>
      <description>Docker 网络实现 Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。 基本原</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 命名空间</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/namespace/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:22 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/namespace/</guid>
      <description>命名空间 命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 联合文件系统</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/ufs/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:22 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/ufs/</guid>
      <description>联合文件系统 联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 -</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/how_connect/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/how_connect/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 -</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/commit/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/commit/</guid>
      <description>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习 容器 一节。 利用 commit 理解镜像构成 注意： docker commit 命令除了学习之外，还有一些特殊的应用场合，比如</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 -  热门镜像介绍</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/readme/</guid>
      <description>热门镜像介绍 本章将介绍一些热门镜像的功能，使用方法等。包括 Ubuntu、CentOS、MySQL、MongoDB、Redis、Nginx、W</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - ADD 更高级的复制文件</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/add/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/add/</guid>
      <description>ADD 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &amp;lt;源路径&amp;gt; 可以是一个 URL，这种情况下，Do</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Alpine</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/alpine/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/alpine/</guid>
      <description>Alpine 简介 Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - ARG 构建参数</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/arg/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/arg/</guid>
      <description>ARG 构建参数 格式：ARG &amp;lt;参数名&amp;gt;[=&amp;lt;默认值&amp;gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Busybox</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/busybox/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/busybox/</guid>
      <description>Busybox 简介 BusyBox 是一个集成了一百多个最常用 Linux 命令和工具（如 cat、echo、grep、mount、telnet 等）的精简工具箱，它只需要几 MB 的大小，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CentOS 安装 Docker CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/centos/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/centos/</guid>
      <description>CentOS 安装 Docker CE 警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker. 准备工作 系统要求 Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CentOS/Fedora</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/centos/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/centos/</guid>
      <description>CentOS/Fedora CentOS 系统简介 CentOS 和 Fedora 都是基于 Redhat 的常见 Linux 分支。CentOS 是目前企业级服务器的常用操作系统；Fedora 则主要面向个人桌面用户。 CentOS（C</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CI/CD</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/readme/</guid>
      <description>CI/CD 持续集成(Continuous integration) 是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CMD 容器启动命令</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/cmd/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/cmd/</guid>
      <description>CMD 容器启动命令 CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD &amp;lt;命令&amp;gt; exec 格式：CMD [&amp;quot;可执行文件&amp;quot;, &amp;q</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Compose 命令说明</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/commands/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/commands/</guid>
      <description>Compose 命令说明 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Compose 模板文件</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/compose_file/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/compose_file/</guid>
      <description>Compose 模板文件 模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Compose 简介</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/introduction/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/introduction/</guid>
      <description>Compose 简介 Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。 其代码目前在 https://github.com/docker/compose 上开源。 Compose 定位是 「定义和运行多</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - COPY 复制文件</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/copy/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/copy/</guid>
      <description>COPY 复制文件 格式： COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;源路径&amp;gt;... &amp;lt;目标路径&amp;gt; COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&amp;quot;&amp;lt;源路径1&amp;gt;&amp;quot;,... &amp;qu</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CoreOS</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/coreos/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/coreos/readme/</guid>
      <description>CoreOS CoreOS 的设计是为你提供能够像谷歌一样的大型互联网公司一样的基础设施管理能力来动态扩展和管理的计算能力。 CoreOS 的安装文件和运行依赖非常小，它提供了精</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CoreOS 介绍</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/coreos/intro/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/coreos/intro/</guid>
      <description>CoreOS 介绍 CoreOS 对 Docker 甚至容器技术的发展都带来了巨大的推动作用。其提供了运行现代基础设施的特性，支持大规模服务部署，使得在基于最小化的现代操作系统上构</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - CoreOS 工具介绍</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/coreos/intro_tools/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/coreos/intro_tools/</guid>
      <description>CoreOS 工具介绍 CoreOS 内置了 服务发现，容器管理 工具。 服务发现 CoreOS 的第一个重要组件就是使用 etcd 来实现的服务发现。在 CoreOS 中 etcd 默认以 rkt 容器方式运行。 etcd 使用方法请查</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Debian 安装 Docker CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/debian/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/debian/</guid>
      <description>Debian 安装 Docker CE 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker. 准备工作 系统要求 Docker CE 支持以下版本的 Debian 操作系统： Buster 10 Stretch 9 卸载旧版本 旧版本的 Docker 称</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Debian/Ubuntu</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/debian/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/debian/</guid>
      <description>Debian/Ubuntu Debian 和 Ubuntu 都是目前较为流行的 Debian 系 的服务器操作系统，十分适合研发场景。Docker Hub 上提供了官方镜像，国内各大容器云服务也基本都提供了相应的支持</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker Compose 项目</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/readme/</guid>
      <description>Docker Compose 项目 Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。 本章将介绍 Compose 项目情况以及安装和使用。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker Hub</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/repository/dockerhub/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/repository/dockerhub/</guid>
      <description>Docker Hub 目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 2,650,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 注册 你可以在 https://hub.docker.com 免费</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker Machine 项目</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/machine/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/machine/readme/</guid>
      <description>Docker Machine 项目 Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。 Docker Machine 项目基于 Go 语言实现，目前在 Github 上进行维护。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker Registry</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/repository/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/repository/</guid>
      <description>Docker Registry 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Do</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker — 从入门到实践</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/readme/</guid>
      <description>Docker — 从入门到实践 Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 三剑客之 Docker Swarm</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm/readme/</guid>
      <description>Docker 三剑客之 Docker Swarm Docker Swarm 是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。 使用它，用户可以将多个 Docker 主机封装为单个</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 中的网络功能介绍</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/network/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/network/readme/</guid>
      <description>Docker 中的网络功能介绍 Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 命令查询</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/command/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/command/readme/</guid>
      <description>Docker 命令查询 基本语法 Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。 客户端命令：基本命令格式为 docker [OPTIONS] COMMAND</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/container/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/container/</guid>
      <description>Docker 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 开源项目</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/opensource/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/opensource/readme/</guid>
      <description>Docker 开源项目 本章介绍 Docker 开源的项目。随着 Docker 功能的越来越多，Docker 也加快了开源的步伐，Docker 未来会将引擎拆分为更多开放组件，对用于组装</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 数据管理</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/data_management/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/data_management/readme/</guid>
      <description>Docker 数据管理 这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式： 数据卷（Volumes） 挂载主机目录 (Bind mounts)</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker 镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/image/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/image/</guid>
      <description>Docker 镜像 我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Dockerfile 指令详解</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/readme/</guid>
      <description>Dockerfile 指令详解 我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Dockerfile 最佳实践</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/best_practices/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/best_practices/</guid>
      <description>Dockerfile 最佳实践 本附录是笔者对 Docker 官方文档中 Best practices for writing Dockerfiles 的理解与翻译。 一般性的指南和建议 容器应该是短暂的 通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Docker服务端的防护</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/daemon_sec/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/daemon_sec/</guid>
      <description>Docker服务端的防护 运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。 首先，确保只</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Drone</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/readme/</guid>
      <description>Drone 基于 Docker 的 CI/CD 工具 Drone 所有编译、测试的流程都在 Docker 容器中进行。 开发者只需在项目中包含 .drone.yml 文件，将代码推送到 git 仓库，Drone 就能够自动化的进行编译、</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Drone Demo</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/demo/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/demo/readme/</guid>
      <description>Drone Demo</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - ENTRYPOINT 入口点</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/entrypoint/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/entrypoint/</guid>
      <description>ENTRYPOINT 入口点 ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - ENV 设置环境变量</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/env/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/env/</guid>
      <description>ENV 设置环境变量 格式有两种： ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt; ENV &amp;lt;key1&amp;gt;=&amp;lt;value1&amp;gt; &amp;lt;key2&amp;gt;=&amp;lt;value2&amp;gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - etcd</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/readme/</guid>
      <description>etcd etcd 是 CoreOS 团队发起的一个管理配置信息和服务发现（Service Discovery）的项目，在这一章里面，我们将基于 etcd 3.x 版本介绍该项目的目标，安</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - etcd 集群</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/cluster/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/cluster/</guid>
      <description>etcd 集群 下面我们使用 Docker Compose 模拟启动一个 3 节点的 etcd 集群。 编辑 docker-compose.yml 文件 version: &amp;quot;3.6&amp;quot; services: node1: image: quay.io/coreos/etcd:v3.4.0 volumes: - node1-data:/etcd-data expose: - 2379 - 2380 networks: cluster_net: ipv4_address: 172.16.238.100 environment: - ETCDCTL_API=3 command: - /usr/local/bin/etcd - --data-dir=/etcd-data - --name - node1 - --initial-advertise-peer-urls - http://172.16.238.100:2380 - --listen-peer-urls - http://0.0.0.0:2380 - --advertise-client-urls</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - EXPOSE 声明端口</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/expose/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/expose/</guid>
      <description>EXPOSE 声明端口 格式为 EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Fedora 安装 Docker CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/fedora/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/fedora/</guid>
      <description>Fedora 安装 Docker CE 警告：切勿在没有配置 Docker dnf 源的情况下直接使用 dnf 命令安装 Docker. 准备工作 系统要求 Docker CE 支持以下版本的 Fedora 操作系统： 28 29 30 卸载旧版本 旧版本的 Docker 称为</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - GitHub Actions</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/actions/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/actions/readme/</guid>
      <description>GitHub Actions GitHub Actions 是 GitHub 推出的一款 CI/CD 工具。 我们可以在每个 job 的 step 中使用 Docker 执行构建步骤。 on: push name: CI jobs: my-job: name: Build runs-on: ubuntu-latest steps: - uses: actions/checkout@master with: fetch-depth: 2 - name: run docker container uses: docker://golang:alpine with: args: go version 参考资料 Actions Docs</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - HEALTHCHECK 健康检查</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/healthcheck/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/healthcheck/</guid>
      <description>HEALTHCHECK 健康检查 格式： HEALTHCHECK [选项] CMD &amp;lt;命令&amp;gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - kubectl 使用</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/kubectl/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/kubectl/</guid>
      <description>kubectl 使用 kubectl 是 Kubernetes 自带的客户端，可以用它来直接操作 Kubernetes。 使用格式有两种： kubectl [flags] kubectl [command] get 显示一个或多个资源 describe 显示资源详情 create 从文件或标准输</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Kubernetes</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/readme/</guid>
      <description>Kubernetes Kubernetes 是 Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。 建于 Docker 之上的 Kubernetes 可以构建一个容器的调度服务</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - LinuxKit</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/opensource/linuxkit/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/opensource/linuxkit/</guid>
      <description>LinuxKit LinuxKit 这个工具可以将多个 Docker 镜像组成一个最小化、可自由定制的 Linux 系统，最后的生成的系统只有几十 M 大小，可以很方便的在云端进行部署。 下面我们在 macOS 上通</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - macOS 安装 Docker Desktop CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/mac/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/mac/</guid>
      <description>macOS 安装 Docker Desktop CE 系统要求 Docker Desktop for Mac 要求系统最低为 macOS Sierra 10.12。 安装 使用 Homebrew 安装 Homebrew 的 Cask 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： $ brew</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Mesos - 优秀的集群资源调度平台</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/readme/</guid>
      <description>Mesos - 优秀的集群资源调度平台 Mesos 项目是源自 UC Berkeley 的对集群资源进行抽象和管理的开源项目，类似于操作系统内核，用户可以使用它很容易地实现分布式应用的自</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Mesos 安装与使用</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/installation/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/installation/</guid>
      <description>Mesos 安装与使用 以 Mesos 结合 Marathon 应用框架为例，来看下如何快速搭建一套 Mesos 平台。 Marathon 是可以跟 Mesos 一起协作的一个 framework，基于 Scala 实现，可以实现保持应用</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Mesos 配置项解析</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/configuration/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/configuration/</guid>
      <description>Mesos 配置项解析 Mesos 支持在运行时通过命令行参数形式提供的配置项。如果是通过系统服务方式启动，也支持以配置文件或环境变量方式给出。当然，实际上最终是</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Nexus3.x 的私有仓库</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/repository/nexus3_registry/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/repository/nexus3_registry/</guid>
      <description>Nexus3.x 的私有仓库 使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry 程序。在企业</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - NoSQL 数据库实现</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/mongodb/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/mongodb/</guid>
      <description>MongoDB 基本信息 MongoDB 是开源的 NoSQL 数据库实现。 该仓库位于 https://hub.docker.com/_/mongo/ ，提供了 MongoDB 2.x ~ 4.x 各个版本的镜像。 使用方法 默认会在 27017 端口启动数据库。 $ docker run --name mongo -d mongo 使用其他应用连</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - ONBUILD 为他人做嫁衣裳</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/onbuild/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/onbuild/</guid>
      <description>ONBUILD 为他人做嫁衣裳 格式：ONBUILD &amp;lt;其它指令&amp;gt;。 ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Swarm mode</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/readme/</guid>
      <description>Swarm mode Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。请注意与旧的 Docker Swarm 区分开来。 Swarm mode 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - SWarm mode 与滚动升级</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/rolling_update/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/rolling_update/</guid>
      <description>SWarm mode 与滚动升级 在 部署服务 一节中我们使用 nginx:1.13.7-alpine 镜像部署了一个名为 nginx 的服务。 现在我们想要将 NGINX 版本升级到 1.13.12，那么在 Swarm mode 中如何升级服务呢？ 你</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Ubuntu 安装 Docker CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/ubuntu/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/ubuntu/</guid>
      <description>Ubuntu 安装 Docker CE 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker. 准备工作 系统要求 Docker CE 支持以下版本的 Ubuntu 操作系统： Disco 19.04 Cosmic 18.10 Bionic 18.04 (LTS) Xenial 16.04 (LTS) Docker CE 可以安</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - USER 指定当前用户</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/user/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/user/</guid>
      <description>USER 指定当前用户 格式：USER &amp;lt;用户名&amp;gt;[:&amp;lt;用户组&amp;gt;] USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - VOLUME 定义匿名卷</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/volume/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/volume/</guid>
      <description>VOLUME 定义匿名卷 格式为： VOLUME [&amp;quot;&amp;lt;路径1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;路径2&amp;gt;&amp;quot;...] VOLUME &amp;lt;路径</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - Windows 10 安装 Docker Desktop CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/windows/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/windows/</guid>
      <description>Windows 10 安装 Docker Desktop CE 系统要求 Docker Desktop for Windows 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。 安装 点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Windows。 下载</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - WORKDIR 指定工作目录</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/workdir/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/workdir/</guid>
      <description>WORKDIR 指定工作目录 格式为 WORKDIR &amp;lt;工作目录路径&amp;gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 为什么要使用 Docker？</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/introduction/why/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/introduction/why/</guid>
      <description>为什么要使用 Docker？ 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源 由于容器不需要进行</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 亚马逊云</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/aws/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/aws/</guid>
      <description>亚马逊云 AWS，即 Amazon Web Services，是亚马逊（Amazon）公司的 IaaS 和 PaaS 平台服务。AWS 提供了一整套基础设施和应用程序服务，使用户几乎能</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 什么是 Docker</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/introduction/what/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/introduction/what/</guid>
      <description>什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 什么是 etcd</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/intro/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/intro/</guid>
      <description>什么是 etcd etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。我们知道，在分</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/usage/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/usage/</guid>
      <description>使用 术语 首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/machine/usage/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/machine/usage/</guid>
      <description>使用 Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。 创建本地主机实例 Virtualbox 驱动 使用 virtualbox 类型的驱动，创建一台 Docker 主机，命名为 test。 $ docker-machine create -d virtualbox</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 `BuildKit` 构建镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/buildkit/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/buildkit/</guid>
      <description>使用 BuildKit 构建镜像 BuildKit 是下一代的镜像构建组件，在 https://github.com/moby/buildkit 开源。 注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（Docker Hub 自动构建、腾讯云容</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 `Buildx` 构建镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/buildx/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/buildx/</guid>
      <description>使用 Buildx 构建镜像 BuildKit 是下一代的镜像构建组件，在 https://github.com/moby/buildkit 开源。 注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（Docker Hub 自动构建、腾讯云容</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 buildx 构建多种系统架构支持的 Docker 镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/buildx_multi-arch-images/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/buildx_multi-arch-images/</guid>
      <description>使用 buildx 构建多种系统架构支持的 Docker 镜像 在之前的版本中构建多种系统架构支持的 Docker 镜像，要想使用统一的名字必须使用 $ docker manifest 命令。 在 Docker 19.03+ 版本中可以使用 $ docker</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 Django</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/django/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/django/</guid>
      <description>使用 Django 本小节内容适合 Python 开发人员阅读。 我们现在将使用 Docker Compose 配置并运行一个 Django/PostgreSQL 应用。 在一切工作开始前，需要先编辑好三个必要的文件。 第一步，因为应用将</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 Docker 镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/readme/</guid>
      <description>使用 Docker 镜像 在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。 Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 Dockerfile 定制镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/build/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/build/</guid>
      <description>使用 Dockerfile 定制镜像 从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 etcdctl</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/etcdctl/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/etcdctl/</guid>
      <description>使用 etcdctl etcdctl 是一个命令行客户端，它能提供一些简洁的命令，供用户直接跟 etcd 服务打交道，而无需基于 HTTP API 方式。这在某些情况下将很方便，例如用户对服务进行</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 etcdctl v2</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/etcdctl-v2/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/etcdctl-v2/</guid>
      <description>使用 etcdctl v2 etcdctl 是一个命令行客户端，它能提供一些简洁的命令，供用户直接跟 etcd 服务打交道，而无需基于 HTTP API 方式。这在某些情况下将很方便，例如用户对服务进</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 Rails</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/rails/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/rails/</guid>
      <description>使用 Rails 本小节内容适合 Ruby 开发人员阅读。 我们现在将使用 Compose 配置并运行一个 Rails/PostgreSQL 应用。 在一切工作开始前，需要先设置好三个必要的文件。 首先，因为应用将要运</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 使用 WordPress</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/wordpress/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/wordpress/</guid>
      <description>使用 WordPress 本小节内容适合 PHP 开发人员阅读。 Compose 可以很便捷的让 Wordpress 运行在一个独立的环境中。 创建空文件夹 假设新建一个名为 wordpress 的文件夹，然后进入这个文件夹。 创</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 其它制作镜像的方式</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/other/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/other/</guid>
      <description>其它制作镜像的方式 除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。 从 rootfs 压缩包导入 格式：doc</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 其它安全特性</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/other_feature/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/other_feature/</guid>
      <description>其它安全特性 除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。 Docker 当前默认只启用了能力机制。用户可以采用多种</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 内核命名空间</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/kernel_ns/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/kernel_ns/</guid>
      <description>内核命名空间 Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 docker run 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。 命名</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 内核能力机制</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/kernel_capability/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/kernel_capability/</guid>
      <description>内核能力机制 能力机制（Capability）是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 列出镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/list/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/list/</guid>
      <description>列出镜像 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.2 fe9198c04d62 5 days ago 342 MB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 00285df0df87 5 days ago 342 MB</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 创建 Swarm 集群</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/create/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/create/</guid>
      <description>创建 Swarm 集群 阅读 基本概念 一节我们知道 Swarm 集群由 管理节点 和 工作节点 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 Swarm 集群。 初始化集群 在</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 删除容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/rm/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/rm/</guid>
      <description>删除容器 可以使用 docker container rm 来删除一个处于终止状态的容器。例如 $ docker container rm trusting_newton trusting_newton 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 删除本地镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/rm/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/rm/</guid>
      <description>删除本地镜像 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： $ docker image rm [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; ...] 用 ID、镜像</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 原理与架构</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/architecture/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/architecture/</guid>
      <description>原理与架构 首先，再次需要强调 Mesos 自身只是一个资源调度框架，并非一整套完整的应用管理平台，所以只有 Mesos 自己是不能干活的。但是基于 Mesos，可以比</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 参考文档</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/references/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/dockerfile/references/</guid>
      <description>参考文档 Dockerfie 官方文档：https://docs.docker.com/engine/reference/builder/ Dockerfile 最佳实践文档：htt</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 可嵌入到 HTML 中，尤其适合 web 开发</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/php/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/php/</guid>
      <description>PHP 基本信息 PHP（Hypertext Preprocessor 超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML 中，尤其适合 web 开发</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 后台运行</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/daemon/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/daemon/</guid>
      <description>后台运行 更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 下面举两个例子来说明一下</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 启动容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/run/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/run/</guid>
      <description>启动容器 启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。 因为 Docker 的容器实在太轻量</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 在 Swarm 集群中使用 compose 文件</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/stack/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/stack/</guid>
      <description>在 Swarm 集群中使用 compose 文件 正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 在 Swarm 集群中管理敏感数据</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/secret/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/secret/</guid>
      <description>在 Swarm 集群中管理敏感数据 在动态的、大规模的分布式集群上，管理和分发 密码、证书 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 在 Swarm 集群中管理配置数据</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/config/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/config/</guid>
      <description>在 Swarm 集群中管理配置数据 在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 在 Travis CI 中使用 Docker</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/travis/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/travis/readme/</guid>
      <description>在 Travis CI 中使用 Docker 当代码提交到 GitHub 时，Travis CI 会根据项目根目录 .travis.yml 文件设置的指令，执行一系列操作。 本小节介绍如何在 Travis CI 中使用 Docker 进行持续集成/持</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基于 JavaScript 的可扩展服务端和网络软件开发</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/nodejs/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/nodejs/</guid>
      <description>Node.js 基本信息 Node.js 是基于 JavaScript 的可扩展服务端和网络软件开发平台。 该仓库位于 https://hub.docker.com/_/node/ ，提供了 Node.js 0.10 ~ 12.x 各个版本的镜像。 使用方法 在项目中创建一个 Dockerfil</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本信息</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/centos/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/centos/</guid>
      <description>CentOS 基本信息 CentOS 是流行的 Linux 发行版，其软件包大多跟 RedHat 系列保持一致。 该仓库位于 https://hub.docker.com/_/centos ，提供了 CentOS 从 5 ~ 8 各个版本的镜像。 使用方法 默认会启动一个最小化的 CentOS 环</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本架构</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/design/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/design/</guid>
      <description>基本架构 任何优秀的项目都离不开优秀的架构设计。本小节将介绍 Kubernetes 在架构方面的设计考虑。 基本考虑 如果让我们自己从头设计一套容器管理平台，有如下几个</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本架构</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/arch/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/arch/</guid>
      <description>基本架构 Docker 采用了 C/S 架构，包括客户端和服务端。Docker 守护进程 （Daemon）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本概念</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/basic_concept/readme/</guid>
      <description>基本概念 Docker 包括三个基本概念 * 镜像（Image） * 容器（Container） * 仓库（Repository） 理解了这三个概念，就理解了 Docker 的整个生</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本概念</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/concepts/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/concepts/</guid>
      <description>基本概念 节点（Node）：一个节点是一个运行 Kubernetes 中的主机。 容器组（Pod）：一个 Pod 对应于由若干容器组成的一个容器组，同个组内的容器共享一个存储</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 基本概念</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/overview/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/overview/</guid>
      <description>基本概念 Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。 使用 Swarm 集群之前需要了解以下几个概念。 节点 运行 Docker 的主机可以主动初始化一个 Swarm 集群</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 外部访问容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/network/port_mapping/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/network/port_mapping/</guid>
      <description>外部访问容器 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 多阶段构建</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/multistage-builds/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/multistage-builds/readme/</guid>
      <description>多阶段构建 之前的做法 在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式： 全部放入一个 Dockerfile 一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 如何调试 Docker</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/debug/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/debug/</guid>
      <description>如何调试 Docker 开启 Debug 模式 在 dockerd 配置文件 daemon.json（默认位于 /etc/docker/）中添加 { &amp;quot;debug&amp;quot;: true } 重启守护进程。 $ sudo kill -SIGHUP $(pidof dockerd) 此时 dockerd 会在</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 安全</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/readme/</guid>
      <description>安全 评估 Docker 的安全性时，主要考虑三个方面: 由内核的命名空间和控制组机制提供的容器内在安全 Docker 程序（特别是服务端）本身的抗攻击性 内核安全性的加强机</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 安装</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/etcd/install/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/etcd/install/</guid>
      <description>安装 etcd 基于 Go 语言实现，因此，用户可以从 项目主页 下载源代码自行编译，也可以下载编译好的二进制文件，甚至直接使用制作好的 Docker 镜像文件来体验。 注意：</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 安装</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/machine/install/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/machine/install/</guid>
      <description>安装 Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。 macOS、Windows Docker Desktop for Mac/Windows 自带 docker-machine 二进制包，安装</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 安装 Docker</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/readme/</guid>
      <description>安装 Docker Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。 Docker CE 分为 stable test 和 nightly 三个更新</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 安装与卸载</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/compose/install/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/compose/install/</guid>
      <description>安装与卸载 Compose 支持 Linux、macOS、Windows 10 三大平台。 Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 实战多阶段构建 Laravel 镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/multistage-builds/laravel/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/multistage-builds/laravel/</guid>
      <description>实战多阶段构建 Laravel 镜像 本节适用于 PHP 开发者阅读。 准备 新建一个 Laravel 项目或在已有的 Laravel 项目根目录下新建 Dockerfile .dockerignore laravel.conf 文件。 在 .dockerignore 文件中写入以下内容。 .idea/ .git/ vendor/ node_modules/ public/js/ public/css/ yarn-error.log</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 容器与云计算</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/readme/</guid>
      <description>容器与云计算 Docker 目前已经得到了众多公有云平台的支持，并成为除虚拟机之外的核心云业务。 除了 AWS、Google、Azure、Docker 官方云服</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 容器互联</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/network/linking/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/network/linking/</guid>
      <description>容器互联 如果你之前有 Docker 使用经验，你可能已经习惯了使用 --link 参数来使容器互联。 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 容器格式</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/container_format/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/container_format/</guid>
      <description>容器格式 最初，Docker 采用了 LXC 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 容器访问控制</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/access_control/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/access_control/</guid>
      <description>容器访问控制 容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。 容器访问</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 导出和导入容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/import_export/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/import_export/</guid>
      <description>导出和导入容器 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7691a814370e ubuntu:18.04 &amp;quot;/bin/bash&amp;quot; 36 hours ago Exited (0) 21 hours ago test $ docker export 7691a814370e &amp;gt; ubuntu.tar 这样将导出容器</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 工具和示例</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/example/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/example/</guid>
      <description>工具和示例 在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣： pipework Jérôme Petazzoni 编写了一个叫 pipework 的 shell 脚本，可以帮助用户在比较复杂的场景</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 常见应用框架</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/framework/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/framework/</guid>
      <description>常见应用框架 应用框架是实际干活的，可以理解为 Mesos 之上跑的 应用。应用框架注册到 Mesos master 服务上即可使用。 用户大部分时候，只需要跟应用框架打交道。因此，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 常见问题总结</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/faq/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/faq/readme/</guid>
      <description>常见问题总结 镜像相关 如何批量清理临时镜像文件？ 答：可以使用 docker image prune 命令。 如何查看镜像支持的环境变量？ 答：可以使用 docker run IMAGE env 命令。 本地的镜像文件都</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 底层实现</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/readme/</guid>
      <description>底层实现 Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file s</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 开源的 Blog</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/wordpress/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/wordpress/</guid>
      <description>WordPress 基本信息 WordPress 是开源的 Blog 和内容管理系统框架，它基于 PHP 和 MySQL。 该仓库位于 https://hub.docker.com/_/wordpress/ ，提供了 WordPress 4.x ~ 5.x 版本的镜像。 使用方法 启动容器需要 MySQL 的支持，默认端</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 开源的关系数据库实现</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/mysql/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/mysql/</guid>
      <description>MySQL 基本信息 MySQL 是开源的关系数据库实现。 该仓库位于 https://hub.docker.com/_/mysql/ ，提供了 MySQL 5.5 ~ 8.x 各个版本的镜像。 使用方法 默认会在 3306 端口启动数据库。 $ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql 之后就可</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 开源的内存 Key-Value 数据库</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/redis/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/redis/</guid>
      <description>Redis 基本信息 Redis 是开源的内存 Key-Value 数据库实现。 该仓库位于 https://hub.docker.com/_/redis/ ，提供了 Redis 3.x ~ 5.x 各个版本的镜像。 使用方法 默认会在 6379 端口启动数据库。 $ docker run --name some-redis -d -p 6379:6379 redis 另外还</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 开源的高效的 Web 服务器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/nginx/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/nginx/</guid>
      <description>Nginx 基本信息 Nginx 是开源的高效的 Web 服务器实现，支持 HTTP、HTTPS、SMTP、POP3、IMAP 等协议。 该仓库位于 https://hub.docker.com/_/nginx/ ，提供了 Nginx 1.0 ~ 1.17.x 各个版本的</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 归档项目</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/archive/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/archive/readme/</guid>
      <description>归档项目 以下项目不被官方支持或内容陈旧，将在下一版本中删除。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 快速上手</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/quickstart/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/quickstart/</guid>
      <description>快速上手 目前，Kubernetes 支持在多种环境下的安装，包括本地主机（Fedora）、云服务（Google GAE、AWS 等）。然而最快速体</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 快速配置指南</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/quick_guide/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/quick_guide/</guid>
      <description>快速配置指南 下面是一个跟 Docker 网络相关的命令列表。 其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。 -b BRIDGE 或 --bridge=BRIDGE 指定容器挂载的网桥 --bip=CIDR</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 总结</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/summary/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/summary/</guid>
      <description>总结 总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。 另外，用户可以使用现有工具，比如 Apparmor, SELinux, GRSEC 来增强安全性；</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 挂载主机目录</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/data_management/bind-mounts/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/data_management/bind-mounts/</guid>
      <description>挂载主机目录 挂载一个主机目录作为数据卷 使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。 $ docker run -d -P \ --name web \ # -v /src/webapp:/opt/webapp \ --mount type=bind,source=/src/webapp,target=/opt/webapp \ training/webapp \ python app.py 上面的命令</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 控制组</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/security/control_group/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/security/control_group/</guid>
      <description>控制组 控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。 它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CP</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 控制组</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/underly/cgroups/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/underly/cgroups/</guid>
      <description>控制组 控制组（cgroups）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 操作 Docker 容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/readme/</guid>
      <description>操作 Docker 容器 容器是 Docker 又一核心概念。 简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 操作系统</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/readme/</guid>
      <description>操作系统 目前常用的 Linux 发行版主要包括 Debian/Ubuntu 系列和 CentOS/Fedora 系列。 前者以自带软件包版本较新而出名；后者则宣称运行更稳定一些。选择哪个操作系统取决于读者的具体</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 数据卷</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/data_management/volume/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/data_management/volume/</guid>
      <description>数据卷 数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 日志与监控</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/monitor/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/monitor/</guid>
      <description>日志与监控 Mesos 自身提供了强大的日志和监控功能，某些应用框架也提供了针对框架中任务的监控能力。通过这些接口，用户可以实时获知集群的各种状态。 日志</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 映射容器端口到宿主主机的实现</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/port_mapping/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/port_mapping/</guid>
      <description>映射容器端口到宿主主机的实现 默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。 容器访问外部实现 容器所有到外部网络的连</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 本章小结</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/os/summary/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/os/summary/</guid>
      <description>本章小结 本章讲解了典型操作系统镜像的下载和使用。 除了官方的镜像外，在 Docker Hub 上还有许多第三方组织或个人上传的 Docker 镜像。 读者可以根据具体情况来选择。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 本章小结</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/summary/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/summary/</guid>
      <description>本章小结 本章介绍了公有云服务对 Docker 的积极支持，以及新出现的容器云平台。 事实上，Docker 技术的出现自身就极大推动了云计算行业的发展。 通过整合</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 本章小结</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/summary/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/summary/</guid>
      <description>本章小结 本章讲解了 Mesos 的安装使用、基本原理和架构，以及支持 Mesos 的重要应用框架。Mesos 最初设计为资源调度器，然而其灵活的设计和对上层框架的优秀</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 构建多种系统架构支持的 Docker 镜像 -- docker manifest 命令详解</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/manifest/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/manifest/</guid>
      <description>构建多种系统架构支持的 Docker 镜像 &amp;ndash; docker manifest 命令详解 我们知道使用镜像创建一个容器，该镜像必须与 Docker 宿主机系统架构一致，例如 Linux x86_64 架构的系统中只能使用 Linux x86_64 的</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 树莓派卡片电脑安装 Docker CE</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/raspberry-pi/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/raspberry-pi/</guid>
      <description>树莓派卡片电脑安装 Docker CE 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker. 系统要求 Docker CE 不仅支持 x86_64 架构的计算机，同时也支持 ARM 架构的计算机，本</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 流行的 Linux 发行版</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/ubuntu/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/repo/ubuntu/</guid>
      <description>Ubuntu 基本信息 Ubuntu 是流行的 Linux 发行版，其自带软件版本往往较新一些。 该仓库位于 https://hub.docker.com/_/ubuntu/ ，提供了 Ubuntu 从 12.04 ~ 19.04 各个版本的镜像。 使用方法 默认会启动一个最小化的 Ubuntu 环境</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 示例：创建一个点到点连接</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/ptp/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/ptp/</guid>
      <description>示例：创建一个点到点连接 默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。 用户有时候需要两个容器之间可以直连通信，而不用通过主</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 私有仓库</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/repository/registry/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/repository/registry/</guid>
      <description>私有仓库 有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。 本节介绍如何使用本地仓库。 docker-registry 是官方提供的工具，可以用于构</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 私有仓库高级配置</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/repository/registry_auth/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/repository/registry_auth/</guid>
      <description>私有仓库高级配置 上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 Docker Compose 搭建一个拥有权限认证、TLS 的私有仓库。 新建一个文件夹，以下</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 简介</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/intro/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/intro/</guid>
      <description>简介 目前与容器相关的云计算主要分为两种类型。 一种是传统的 IaaS 服务商提供对容器相关的服务，包括镜像下载、容器托管等。 另一种是直接基于容器技术对外</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 简介</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/introduction/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/introduction/readme/</guid>
      <description>简介 本章将带领你进入 Docker 的世界。 什么是 Docker？ 用它会带来什么样的好处？ 好吧，让我们带着问题开始这神奇之旅。</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 简介</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/mesos/intro/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/mesos/intro/</guid>
      <description>简介 Mesos 最初由 UC Berkeley 的 AMP 实验室于 2009 年发起，遵循 Apache 协议，目前已经成立了 Mesosphere 公司进行运营。Mesos 可以将整个数据中心的资源（包括 CPU、内存、存储、</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 终止容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/stop/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/stop/</guid>
      <description>终止容器 可以使用 docker container stop 来终止一个运行中的容器。 此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如对于上一章节中只启动了一个终端的容器，用</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 编辑网络配置文件</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/config_file/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/config_file/</guid>
      <description>编辑网络配置文件 Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts, /etc/hostname 和 /etc/resolv.conf 文件。 但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 腾讯云</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/tencentcloud/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/tencentcloud/</guid>
      <description>腾讯云 腾讯云 在架构方面经过多年积累，并且有着多年对海量互联网服务的经验。不管是社交、游戏还是其他领域，都有多年的成熟产品来提供产品服务。腾讯</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 自定义网桥</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/bridge/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/bridge/</guid>
      <description>自定义网桥 除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。 在启动 Docker 服务的时候，使用 -b BRIDGE或--bridge=BRIDGE 来指定使</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 获取镜像</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/pull/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/pull/</guid>
      <description>获取镜像 之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 访问仓库</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/repository/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/repository/readme/</guid>
      <description>访问仓库 仓库（Repository）是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 资源链接</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/resources/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/resources/</guid>
      <description>资源链接 官方网站 Docker 官方主页：https://www.docker.com Docker 官方博客：https://blog.docker.com/ Docker 官方文</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 进入容器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/container/attach_exec/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/container/attach_exec/</guid>
      <description>进入容器 在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 部署 Drone</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/install/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cases/ci/drone/install/</guid>
      <description>部署 Drone 要求 拥有公网 IP、域名 (如果你不满足要求，可以尝试在本地使用 Gogs + Drone) 域名 SSL 证书 (目前国内有很多云服务商提供免费证书) 熟悉 Docker 以及 Docker Compose 熟悉 Git</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 部署服务</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/deploy/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/swarm_mode/deploy/</guid>
      <description>部署服务 我们使用 docker service 命令来管理 Swarm 集群中的服务，该命令只能在管理节点运行。 新建服务 现在我们在上一节创建的 Swarm 集群中运行一个名为 nginx 服务。 $ docker service create --replicas</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 配置 DNS</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/network/dns/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/network/dns/</guid>
      <description>配置 DNS 如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。 在容器中使用 mount 命令可以看到挂载信息： $ mount /dev/disk/by-uuid/1fec...ebdf on /etc/hostname type</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 配置 docker0 网桥</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/docker0/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/docker0/</guid>
      <description>配置 docker0 网桥 Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 镜像加速器</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/install/mirror/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/install/mirror/</guid>
      <description>镜像加速器 国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如： Azure 中国镜像 https://dockerhub.azk8s.cn 阿里云加速器(</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 镜像的实现原理</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/image/internal/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/image/internal/</guid>
      <description>镜像的实现原理 Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。 通常 Union FS 有</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 阿里云</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/cloud/alicloud/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/cloud/alicloud/</guid>
      <description>阿里云 阿里云 创立于 2009 年，是中国较早的云计算平台。阿里云致力于提供安全、可靠的计算和数据处理能力。 阿里云 的客户群体中，活跃着微博、知乎、魅族、</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 附录</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/appendix/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/appendix/readme/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 项目简介</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/intro/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/intro/</guid>
      <description>项目简介 Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言。Kubernete</description>
    </item>
    
    <item>
      <title>Docker 从入门到实践 - 高级网络配置</title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/readme/</link>
      <pubDate>Mon, 11 Nov 2019 22:27:21 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/advanced_network/readme/</guid>
      <description>高级网络配置 注意：本章属于 Docker 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 Docker Compose 一节。 本章将介绍 Docker 的一些高级网络配置和选项。 当 Docker 启动</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -gulp 入门指南</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/readme/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/readme/</guid>
      <description>gulp 入门指南 gulp 是基于 node 实现 Web 前端自动化开发的工具，利用它能够极大的提高开发效率。 在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 压缩 CSS</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter3/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter3/</guid>
      <description>使用 gulp 压缩 CSS 请务必理解如下章节后阅读此章节： 安装 Node 和 gulp 使用 gulp 压缩 JS 压缩 css 代码可降低 css 文件大小，提高页面打开速度。 我们接着将规律转换为 gulp 代码 规</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 压缩 JS</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter2/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter2/</guid>
      <description>使用 gulp 压缩 JS 请务必理解如下章节后阅读此章节： 安装 Node 和 gulp 压缩 js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 压缩图片</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter4/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter4/</guid>
      <description>使用 gulp 压缩图片 请务必理解如下章节后阅读此章节： 安装 Node 和 gulp 使用 gulp 压缩 JS 压缩 图片文件可降低文件大小，提高图片加载速度。 找到规律转换为 gulp 代码 规律 找</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 构建一个项目</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter7/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter7/</guid>
      <description>使用 gulp 构建一个项目 请务必理解前面的章节后阅读此章节： 本章将介绍 - gulp-watch-path - stream-combiner2 - gulp-sourcemaps - gulp-autoprefixer 并将之前所有章节的内容组合起来编写一个前端项目所需的 gulp 代码。 你</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 编译 LESS</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter5/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter5/</guid>
      <description>使用 gulp 编译 LESS 请务必理解如下章节后阅读此章节： 安装 Node 和 gulp 使用 gulp 压缩 JS Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -使用 gulp 编译 Sass</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter6/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter6/</guid>
      <description>使用 gulp 编译 Sass 无论是 node-sass 还是 ruby-sass 使用 npm 安装都非常的慢，甚至会装不上。及其不利于团队协作。建议使用 less 作为 css 预处理器。 如果因为 less 不支持自定义函数选择用</description>
    </item>
    
    <item>
      <title>Gulp 入门指南 -安装 Node 和 gulp</title>
      <link>https://blog.zshipu.com/article/post/gulp/20191111/chapter1/</link>
      <pubDate>Mon, 11 Nov 2019 21:01:32 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/gulp/20191111/chapter1/</guid>
      <description>安装 Node 和 gulp gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node 是一个基于Chrome JavaScript V8引擎建立的一个平台，可以利用它实现 Web服务，做类似</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 -</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-08-grpcurl/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-08-grpcurl/</guid>
      <description>4.8 grpcurl工具 Protobuf本身具有反射功能，可以在运行时获取对象的Proto文件。gRPC同样也提供了一个名为reflection</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.10 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-10-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-10-ext/</guid>
      <description>3.10 补充说明 如果是纯粹学习汇编语言，则可以从《深入理解程序设计：使用Linux汇编语言》开始，该书讲述了如何以C语言的思维变现汇编程序。如果是</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.7 汇编语言的威力</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-07-hack-asm/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-07-hack-asm/</guid>
      <description>3.7 汇编语言的威力 汇编语言的真正威力来自两个维度：一是突破框架限制，实现看似不可能的任务；二是突破指令限制，通过高级指令挖掘极致的性能。对于第</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.8 例子：Goroutine ID</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-08-goroutine-id/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-08-goroutine-id/</guid>
      <description>3.8 例子：Goroutine ID 在操作系统中，每个进程都会有一个唯一的进程编号，每个线程也有自己唯一的线程编号。同样在Go语言中，每个Gorou</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.9 Delve调试器</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-09-debug/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-09-debug/</guid>
      <description>3.9 Delve调试器 目前Go语言支持GDB、LLDB和Delve几种调试器。其中GDB是最早支持的调试工具，LLDB是macOS系统推荐的标准</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.1 RPC入门</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-01-rpc-intro/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-01-rpc-intro/</guid>
      <description>4.1 RPC入门 RPC是远程过程调用的简称，是分布式系统中不同节点间流行的通信方式。在互联网时代，RPC已经和IPC一样成为一个不可或缺的基础构</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.2 Protobuf</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-02-pb-intro/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-02-pb-intro/</guid>
      <description>4.2 Protobuf Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protob</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.3 玩转RPC</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-03-netrpc-hack/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-03-netrpc-hack/</guid>
      <description>4.3 玩转RPC 在不同的场景中RPC有着不同的需求，因此开源的社区就诞生了各种RPC框架。本节我们将尝试Go内置RPC框架在一些比较特殊场景的用</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.4 gRPC入门</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-04-grpc/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-04-grpc/</guid>
      <description>4.4 gRPC入门 gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP/2协议设计，可以基于一个HT</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.5 gRPC进阶</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-05-grpc-hack/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-05-grpc-hack/</guid>
      <description>4.5 gRPC进阶 作为一个基础的RPC框架，安全和扩展是经常遇到的问题。本节将简单介绍如何对gRPC进行安全认证。然后介绍通过gRPC的截取器特</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.6 gRPC和Protobuf扩展</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-06-grpc-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-06-grpc-ext/</guid>
      <description>4.6 gRPC和Protobuf扩展 目前开源社区已经围绕Protobuf和gRPC开发出众多扩展，形成了庞大的生态。本节我们将简单介绍验证器和R</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.7 pbgo 基于Protobuf的框架</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-07-pbgo/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-07-pbgo/</guid>
      <description>4.7 pbgo: 基于Protobuf的框架 pbgo是我们专门针对本节内容设计的较为完整的迷你框架，它基于Protobuf的扩展语法，通过插件自动生成rp</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 4.9 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-09-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/ch4-09-ext/</guid>
      <description>4.9 补充说明 目前专门讲述RPC的图书比较少。目前Protobuf和gRPC的官网都提供了详细的参考资料和例子。本章重点讲述了Go标准库的RPC</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.1 Web 开发简介</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-01-introduction/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-01-introduction/</guid>
      <description>5.1 Web 开发简介 因为Go的net/http包提供了基础的路由函数组合与丰富的功能函数。所以在社区里流行一种用Go编写API不需要框架的观点，在我</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.10 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-10-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-10-ext/</guid>
      <description>5.10 补充说明 现代的软件工程是离不开Web的，广义地来讲，Web甚至可以不用非得基于http协议。只要是CS或者BS架构，都可以认为是Web系统</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.2 router 请求路由</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-02-router/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-02-router/</guid>
      <description>5.2 router 请求路由 在常见的Web框架中，router是必备的组件。Go语言圈子里router也时常被称为http的multiplexer。在上一节</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.3 中间件</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-03-middleware/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-03-middleware/</guid>
      <description>5.3 中间件 本章将对现在流行的Web框架中的中间件(middleware)技术原理进行分析，并介绍如何使用中间件技术将业务和非业务代码功能进行解</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.4 validator请求校验</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-04-validator/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-04-validator/</guid>
      <description>5.4 validator请求校验 社区里曾经有人用*图 5-10*来嘲笑PHP： 图 5-10 validator流程 这其实是一个语言无关的场景，需要进行字段校</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.5 Database 和数据库打交道</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-05-database/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-05-database/</guid>
      <description>5.5 Database 和数据库打交道 本节将对db/sql官方标准库作一些简单分析，并介绍一些应用比较广泛的开源ORM和SQL Builder。并从企业级应用开发</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.6 Ratelimit 服务流量限制</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-06-ratelimit/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-06-ratelimit/</guid>
      <description>5.6 Ratelimit 服务流量限制 计算机程序可依据其瓶颈分为磁盘IO瓶颈型，CPU计算瓶颈型，网络带宽瓶颈型，分布式场景下有时候也会外部系统而导致自身瓶颈。 W</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.7 layout 常见大型 Web 项目分层</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-07-layout-of-web-project/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-07-layout-of-web-project/</guid>
      <description>5.7 layout 常见大型 Web 项目分层 流行的Web框架大多数是MVC框架，MVC这个概念最早由Trygve Reenskaug在1978年提出，为了能够对GU</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.8 接口和表驱动开发</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-08-interface-and-web/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-08-interface-and-web/</guid>
      <description>5.8 接口和表驱动开发 在Web项目中经常会遇到外部依赖环境的变化，比如： 公司的老存储系统年久失修，现在已经没有人维护了，新的系统上线也没有考虑平</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 5.9 灰度发布和 A/B test</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-09-gated-launch/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/ch5-09-gated-launch/</guid>
      <description>5.9 灰度发布和 A/B test 中型的互联网公司往往有着以百万计的用户，而大型互联网公司的系统则可能要服务千万级甚至亿级的用户需求。大型系统的请求流入往往是</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.1 分布式id生成器</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-01-dist-id/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-01-dist-id/</guid>
      <description>6.1 分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.2 分布式锁</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-02-lock/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-02-lock/</guid>
      <description>6.2 分布式锁 在单机程序并发或并行修改全局变量时，需要对修改行为加锁以创造临界区。为什么需要加锁呢？我们看看在不加锁的情况下并发计数会发生什么情</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.3 延时任务系统</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-03-delay-job/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-03-delay-job/</guid>
      <description>6.3 延时任务系统 我们在做系统时，很多时候是处理实时的任务，请求来了马上就处理，然后立刻给用户以反馈。但有时也会遇到非实时的任务，比如确定的时间</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.4 分布式搜索引擎</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-04-search-engine/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-04-search-engine/</guid>
      <description>6.4 分布式搜索引擎 在Web一章中，我们提到MySQL很脆弱。数据库系统本身要保证实时和强一致性，所以其功能设计上都是为了满足这种一致性需求。比</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.5 负载均衡</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-05-load-balance/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-05-load-balance/</guid>
      <description>6.5 负载均衡 本节将会讨论常见的分布式系统负载均衡手段。 6.5.1 常见的负载均衡思路 如果我们不考虑均衡的话，现在有n个服务节点，我们完成业务流程只需要从</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.6 分布式配置管理</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-06-config/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-06-config/</guid>
      <description>6.6 分布式配置管理 在分布式系统中，常困扰我们的还有上线问题。虽然目前有一些优雅重启方案，但实际应用中可能受限于我们系统内部的运行情况而没有办法</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.7 分布式爬虫</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-07-crawler/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-07-crawler/</guid>
      <description>6.7 分布式爬虫 互联网时代的信息爆炸是很多人倍感头痛的问题，应接不暇的新闻、信息、视频，无孔不入地侵占着我们的碎片时间。但另一方面，在我们真正需</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 6.8 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-08-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/ch6-08-ext/</guid>
      <description>6.8 补充说明 分布式是很大的领域，本章中的介绍只能算是对领域的管中窥豹。因为大型系统流量大，并发高，所以往往很多朴素的方案会变得难以满足需求。人</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - goproxy代理服务</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/examples/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/examples/readme/</guid>
      <description>goproxy代理服务 $ export GOPROXY=https://athens.azurefd.net https://github.com/gomods/athens/releases https://athens.azurefd.net https://docs.gomods.io</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 勘误·第一版第一次印刷</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/errata/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/errata/readme/</guid>
      <description>勘误·第一版第一次印刷 1. ch3.4最后一个图有错误 sum函数的ret+24(FP)改为ret+16(FP) 2. ch3.5 控制流 - for例子有错误 #438 17</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 序言</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/preface-pdf/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/preface-pdf/</guid>
      <description>序言 2009年11月，Google发布了Go语言，在世界范围内引发了轰动。2015年和2016年中国区的Go语言大会分别在上海和北京召开，来</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第3章 Go汇编语言</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/readme/</guid>
      <description>第3章 Go汇编语言 能跑就行，不行加机器。——rfyiamcool &amp;amp; 爱学习的孙老板 跟对人，做对事。——Rhichy Go语言中很多设计思想和工具</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第4章 RPC和Protobuf</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch4-rpc/readme/</guid>
      <description>第4章 RPC和Protobuf 学习编程，重要的是什么？多练、多看、多实践！跨语言学习，掌握基础语法和语言的特性之后，实战，效率来的最快！——</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第5章 go 和 Web</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch5-web/readme/</guid>
      <description>第5章 go 和 Web 不管何种编程语言，适合自己的就是最好的。不管何种编程语言，能稳定实现业务逻辑的就是最好的。世间编程语言千千万，世间程序猿万万千，</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第6章 分布式系统</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:15 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch6-cloud/readme/</guid>
      <description>第6章 分布式系统 被别人指出问题时，别管别人能不能做到，看别人说的对不对，然后完善自己。别人能不能做到是别人的事情，自己能不能做到关系到自己能</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.1 Go语言创世纪</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-01-genesis/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-01-genesis/</guid>
      <description>1.1 Go语言创世纪 Go语言最初由Google公司的Robert Griesemer、Ken Thompson和Rob Pike三个大牛于2007年开</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.2 Hello, World 的革命</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-02-hello-revolution/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-02-hello-revolution/</guid>
      <description>1.2 Hello, World 的革命 在创世纪章节中我们简单介绍了Go语言的演化基因族谱，对其中来自于贝尔实验室的特有并发编程基因做了重点介绍，最后引出了Go语言版的</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.3 数组、字符串和切片</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-03-array-string-and-slice/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-03-array-string-and-slice/</guid>
      <description>1.3 数组、字符串和切片 在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash表（hash表</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.4 函数、方法和接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-04-func-method-interface/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-04-func-method-interface/</guid>
      <description>1.4 函数、方法和接口 函数对应操作序列，是程序的基本组成元素。Go语言中的函数有具名和匿名之分：具名函数一般对应于包级的函数，是匿名函数的一种特</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.5 面向并发的内存模型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-05-mem/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-05-mem/</guid>
      <description>1.5 面向并发的内存模型 在早期，CPU都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.6 常见的并发模式</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-06-goroutine/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-06-goroutine/</guid>
      <description>1.6 常见的并发模式 Go语言最吸引人的地方是它内建的并发支持。Go语言并发体系的理论是C.A.R Hoare在1978年提出的CSP（Commun</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.7 错误和异常</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-07-error-and-panic/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-07-error-and-panic/</guid>
      <description>1.7 错误和异常 错误处理是每个编程语言都要考虑的一个重要话题。在Go语言的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分。 在</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 1.8 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-08-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/ch1-08-ext/</guid>
      <description>1.8 补充说明 本书定位是Go语言进阶图书，因此读者需要有一定的Go语言基础。如果对Go语言不太了解，作者推荐通过以下资料开始学习Go语言。首先是</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.1 快速入门</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-01-hello-cgo/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-01-hello-cgo/</guid>
      <description>2.1 快速入门 本节我们将通过一系列由浅入深的小例子来快速掌握CGO的基本用法。 2.1.1 最简CGO程序 真实的CGO程序一般都比较复杂。不过我们可以由浅入</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.10 编译和链接参数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-10-link/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-10-link/</guid>
      <description>2.10 编译和链接参数 编译和链接参数是每一个C/C++程序员需要经常面对的问题。构建每一个C/C++应用均需要经过编译和链接两个步骤，CGO也是如</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.11 补充说明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-11-ext/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-11-ext/</guid>
      <description>2.11 补充说明 CGO是C语言和Go语言混合编程的技术，因此要想熟练地使用CGO需要了解这两门语言。C语言推荐两本书：第一本是C语言之父编写的《C</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.2 CGO基础</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-02-basic/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-02-basic/</guid>
      <description>2.2 CGO基础 要使用CGO特性，需要安装C/C++构建工具链，在macOS和Linux下是要安装GCC，在windows下是需要安装MinGW</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.3 类型转换</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-03-cgo-types/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-03-cgo-types/</guid>
      <description>2.3 类型转换 最初CGO是为了达到方便从Go语言函数调用C语言函数（用C语言实现Go语言声明的函数）以复用C语言资源这一目的而出现的（因为C语言</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.4 函数调用</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-04-func/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-04-func/</guid>
      <description>2.4 函数调用 函数是C语言编程的核心，通过CGO技术我们不仅仅可以在Go语言中调用C语言函数，也可以将Go语言函数导出为C语言函数。 2.4.1 Go调用C</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.5 内部机制</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-05-internal/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-05-internal/</guid>
      <description>2.5 内部机制 对于刚刚接触CGO用户来说，CGO的很多特性类似魔法。CGO特性主要是通过一个叫cgo的命令行工具来辅助输出Go和C之间的桥接代码</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.6 实战 封装qsort</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-06-qsort/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-06-qsort/</guid>
      <description>2.6 实战: 封装qsort qsort快速排序函数是C语言的高阶函数，支持用于自定义排序比较函数，可以对任意类型的数组进行排序。本节我们尝试基于C</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.7 CGO内存模型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-07-memory/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-07-memory/</guid>
      <description>2.7 CGO内存模型 CGO是架接Go语言和C语言的桥梁，它使二者在二进制接口层面实现了互通，但是我们要注意因两种语言的内存模型的差异而可能引起的</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.8 C&#43;&#43; 类包装</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-08-class/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-08-class/</guid>
      <description>2.8 C++ 类包装 CGO是C语言和Go语言之间的桥梁，原则上无法直接支持C++的类。CGO不支持C++语法的根本原因是C++至今为止还没有一个二进制</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 2.9 静态库和动态库</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-09-static-shared-lib/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/ch2-09-static-shared-lib/</guid>
      <description>2.9 静态库和动态库 CGO在使用C/C++资源的时候一般有三种形式：直接使用源码；链接静态库；链接动态库。直接使用源码就是在import &amp;quo</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.1 快速入门</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-01-basic/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-01-basic/</guid>
      <description>3.1 快速入门 Go汇编程序始终是幽灵一样的存在。我们将通过分析简单的Go程序输出的汇编代码，然后照猫画虎用汇编实现一个简单的输出程序。 3.1.1 实现和声</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.2 计算机结构</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-02-arch/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-02-arch/</guid>
      <description>3.2 计算机结构 汇编语言是直面计算机的编程语言，因此理解计算机结构是掌握汇编语言的前提。当前流行的计算机基本采用的是冯·诺伊曼计算机体系结构（在</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.3 常量和全局变量</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-03-const-and-var/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-03-const-and-var/</guid>
      <description>3.3 常量和全局变量 程序中的一切变量的初始值都直接或间接地依赖常量或常量表达式生成。在Go语言中很多变量是默认零值初始化的，但是Go汇编中定义的</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.4 函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-04-func/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-04-func/</guid>
      <description>3.4 函数 终于到函数了！因为Go汇编语言中，可以也建议通过Go语言来定义全局变量，那么剩下的也就是函数了。只有掌握了汇编函数的基本用法，才能真正</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.5 控制流</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-05-control-flow/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-05-control-flow/</guid>
      <description>3.5 控制流 程序主要有顺序、分支和循环几种执行流程。本节主要讨论如何将Go语言的控制流比较直观地转译为汇编程序，或者说如何以汇编思维来编写Go语</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 3.6 再论函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-06-func-again/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch3-asm/ch3-06-func-again/</guid>
      <description>3.6 再论函数 在前面的章节中我们已经简单讨论过Go的汇编函数，但是那些主要是叶子函数。叶子函数的最大特点是不会调用其他函数，也就是栈的大小是可以</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 目录</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/summary/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/summary/</guid>
      <description>目录 第1章 语言基础 1.1 Go语言创世纪 1.2 Hello, World 的革命 1.3 数组、字符串和切片 1.4 函数、方法和接口 1.5 面向并发的内存模型 1.6 常见的并发模式 1.7 错误和异常 1.8 补充说</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第1章 语言基础</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch1-basic/readme/</guid>
      <description>第1章 语言基础 我不知道，你过去10年为什么不快乐。但相信我，抛掉过去的沉重，使用Go语言，体会最初的快乐！——469856321 搬砖民工也会</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 第2章 CGO编程</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/ch2-cgo/readme/</guid>
      <description>第2章 CGO编程 过去的经验往往是走向未来的枷锁，因为在过气技术中投入的沉没成本会阻碍人们拥抱新技术。——chai2010 曾经一度因未能习得C</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 附录</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/appendix/readme/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/appendix/readme/</guid>
      <description>附录 附录部分主要包含量三个部分：第一部分是摘录量一些Go语言常见的坑和解决方案；第二部分是一些有趣的代码片段；第三部分是作者信息。</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 附录A：Go语言常见坑</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-a-trap/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-a-trap/</guid>
      <description>附录A：Go语言常见坑 这里列举的Go语言常见坑都是符合Go语言语法的，可以正常的编译，但是可能是运行结果错误，或者是有资源泄漏的风险。 可变参</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 附录B：有趣的代码片段</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-b-gems/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-b-gems/</guid>
      <description>附录B：有趣的代码片段 这里收集一些比较有意思的Go程序片段。 自重写程序 UNIX/Go语言之父 Ken Thompson 在1983年的图灵奖演讲 Reflections on Trusting Trust 就给出了一个</description>
    </item>
    
    <item>
      <title>Go语言从入门到精通 - 附录C：作者简介</title>
      <link>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-c-author/</link>
      <pubDate>Thu, 24 Oct 2019 09:47:14 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191024/appendix/appendix-c-author/</guid>
      <description>附录C：作者简介 柴树杉（Github @chai2010; Twitter @chaishushan）Go语言代码贡献者，Dart语言和WebAssembly等技术爱好者，著有</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.1. 函数声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-01/</guid>
      <description>5.1. 函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func name(parameter-list) (result-list) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.10. Recover捕获异常</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-10/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-10/</guid>
      <description>5.10. Recover捕获异常 通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.2. 递归</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-02/</guid>
      <description>5.2. 递归 函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.3. 多返回值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-03/</guid>
      <description>5.3. 多返回值 在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.4. 错误</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04/</guid>
      <description>5.4. 错误 在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数，对各种可能的输入</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.4.1. 错误处理策略</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04-1/</guid>
      <description>5.4.1. 错误处理策略 当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。 首先，</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.4.2. 文件结尾错误（EOF）</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-04-2/</guid>
      <description>5.4.2. 文件结尾错误（EOF） 函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.5. 函数值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-05/</guid>
      <description>5.5. 函数值 在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.6. 匿名函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-06/</guid>
      <description>5.6. 匿名函数 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.6.1. 警告：捕获迭代变量</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-06-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-06-1/</guid>
      <description>5.6.1. 警告：捕获迭代变量 本节，将介绍Go词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.7. 可变参数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-07/</guid>
      <description>5.7. 可变参数 参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.8. Deferred函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-08/</guid>
      <description>5.8. Deferred函数 在findLinks的例子中，我们用http.Get的输出作为html.Parse的输入。只有url的内容的确是HTM</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 5.9. Panic异常</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-09/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5-09/</guid>
      <description>5.9. Panic异常 Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起pain</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch5- 第五章　函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch5/ch5/</guid>
      <description>第五章 函数 函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。函数的机制可以让我们将一个大的工作分解为小的任务，这</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.1. 方法声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-01/</guid>
      <description>6.1. 方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.2. 基于指针对象的方法</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-02/</guid>
      <description>6.2. 基于指针对象的方法 当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.2.1. Nil也是一个合法的接收器类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-02-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-02-1/</guid>
      <description>6.2.1. Nil也是一个合法的接收器类型 就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.3. 通过嵌入结构体来扩展类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-03/</guid>
      <description>6.3. 通过嵌入结构体来扩展类型 来看看ColoredPoint这个类型： gopl.io/ch6/coloredpoint import &amp;quot;image/color&amp;quot; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } 我们完全可以将ColoredPoint</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.4. 方法值和方法表达式</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-04/</guid>
      <description>6.4. 方法值和方法表达式 我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.5. 示例：Bit数组</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-05/</guid>
      <description>6.5. 示例：Bit数组 Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 6.6. 封装</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6-06/</guid>
      <description>6.6. 封装 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch6- 第六章　方法</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch6/ch6/</guid>
      <description>第六章 方法 从90年代早期开始，面向对象编程（OOP）就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对OOP</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.1. 接口约定</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-01/</guid>
      <description>7.1. 接口约定 目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.10. 类型断言</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-10/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-10/</guid>
      <description>7.10. 类型断言 类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.11. 基于类型断言区别错误类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-11/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-11/</guid>
      <description>7.11. 基于类型断言区别错误类型 思考在os包中文件操作返回的错误集合。I/O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.12. 通过类型断言询问行为</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-12/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-12/</guid>
      <description>7.12. 通过类型断言询问行为 下面这段逻辑和net/http包中web服务器负责写入HTTP头字段（例如：&amp;rdquo;Content-type:t</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.13. 类型分支</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-13/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-13/</guid>
      <description>7.13. 类型分支 接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Inte</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.14. 示例：基于标记的XML解码</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-14/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-14/</guid>
      <description>7.14. 示例：基于标记的XML解码 第4.5章节展示了如何使用encoding/json包中的Marshal和Unmarshal函数来将JSON文档</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.15. 一些建议</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-15/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-15/</guid>
      <description>7.15. 一些建议 当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.2. 接口类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-02/</guid>
      <description>7.2. 接口类型 接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。 io.Writer类型是用得最广泛的接口之一</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.3. 实现接口的条件</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-03/</guid>
      <description>7.3. 实现接口的条件 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。例如，*os.File类型实现了io.Reader，W</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.4. flag.Value接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-04/</guid>
      <description>7.4. flag.Value接口 在本章，我们会学到另一个标准的接口类型flag.Value是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.5.  接口值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-05/</guid>
      <description>7.5. 接口值 概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.5.1.  警告：一个包含nil指针的接口不是nil接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-05-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-05-1/</guid>
      <description>7.5.1. 警告：一个包含nil指针的接口不是nil接口 一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.6. sort.Interface接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-06/</guid>
      <description>7.6. sort.Interface接口 排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.7. http.Handler接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-07/</guid>
      <description>7.7. http.Handler接口 在第一章中，我们粗略的了解了怎么用net/http包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.8. error接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-08/</guid>
      <description>7.8. error接口 从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 7.9. 示例：表达式求值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-09/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7-09/</guid>
      <description>7.9. 示例：表达式求值 在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch7- 第七章　接口</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch7/ch7/</guid>
      <description>第七章 接口 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.1. Goroutines</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-01/</guid>
      <description>8.1. Goroutines 在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.10. 示例：聊天服务</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-10/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-10/</guid>
      <description>8.10. 示例：聊天服务 我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goro</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.2. 示例：并发的Clock服务</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-02/</guid>
      <description>8.2. 示例：并发的Clock服务 网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.3. 示例：并发的Echo服务</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-03/</guid>
      <description>8.3. 示例：并发的Echo服务 clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.4. Channels</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04/</guid>
      <description>8.4. Channels 如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.4.1. 不带缓存的Channels</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-1/</guid>
      <description>8.4.1. 不带缓存的Channels 一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.4.2. 串联的Channels（Pipeline）</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-2/</guid>
      <description>8.4.2. 串联的Channels（Pipeline） Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.4.3. 单方向的Channel</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-3/</guid>
      <description>8.4.3. 单方向的Channel 随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个chan</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.4.4. 带缓存的Channels</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-04-4/</guid>
      <description>8.4.4. 带缓存的Channels 带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.5. 并发的循环</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-05/</guid>
      <description>8.5. 并发的循环 本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/t</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.6. 示例：并发的Web爬虫</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-06/</guid>
      <description>8.6. 示例：并发的Web爬虫 在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.7. 基于select的多路复用</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-07/</guid>
      <description>8.7. 基于select的多路复用 下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.8. 示例：并发的目录遍历</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-08/</guid>
      <description>8.8. 示例：并发的目录遍历 在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 8.9. 并发的退出</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-09/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8-09/</guid>
      <description>8.9. 并发的退出 有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch8- 第八章　Goroutines和Channels</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch8/ch8/</guid>
      <description>第八章 Goroutines和Channels 并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。Web服务器会一次处理</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.1. 竞争条件</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-01/</guid>
      <description>9.1. 竞争条件 在一个线性（就是说只有一个goroutine的）的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.2. sync.Mutex互斥锁</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-02/</guid>
      <description>9.2. sync.Mutex互斥锁 在8.6节中，我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个gorouti</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.3. sync.RWMutex读写锁</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-03/</guid>
      <description>9.3. sync.RWMutex读写锁 在100刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob写了一个程序，每秒运行几百次来检查他的银行余</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.4. 内存同步</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-04/</guid>
      <description>9.4. 内存同步 你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.5. sync.Once惰性初始化</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-05/</guid>
      <description>9.5. sync.Once惰性初始化 如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.6. 竞争条件检测</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-06/</guid>
      <description>9.6. 竞争条件检测 即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.7. 示例：并发的非阻塞缓存</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-07/</guid>
      <description>9.7. 示例：并发的非阻塞缓存 本节中我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现但没有现成的库可以解决的问题。这个问</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.8. Goroutines和线程</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08/</guid>
      <description>9.8. Goroutines和线程 在上一章中我们说goroutine和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.8.1. 动态栈</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-1/</guid>
      <description>9.8.1. 动态栈 每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.8.2. Goroutine调度</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-2/</guid>
      <description>9.8.2. Goroutine调度 OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.8.3. GOMAXPROCS</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-3/</guid>
      <description>9.8.3. GOMAXPROCS Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 9.8.4. Goroutine没有ID号</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9-08-4/</guid>
      <description>9.8.4. Goroutine没有ID号 在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（id），并且这个身份信息可以以一个普通</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch9- 第九章　基于共享变量的并发</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:28 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch9/ch9/</guid>
      <description>第九章 基于共享变量的并发 前一章我们介绍了一些使用goroutine和channel这样直接而自然的方式来实现并发的方法。然而这样做我们实际上</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch0- Go语言起源</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-01/</guid>
      <description>Go语言起源 编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch0- Go语言项目</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-02/</guid>
      <description>Go语言项目 所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch0- 更多的信息</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-04/</guid>
      <description>更多的信息 最佳的帮助信息来自Go语言的官方网站，https://golang.org ，它提供了完善的参考文档，包括编程语言规范和标准库等诸多</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch0- 本书的组织</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-03/</guid>
      <description>本书的组织 我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型语言，还是类似Python、Ruby、Ja</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch0- 致谢</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch0/ch0-05/</guid>
      <description>致谢 Rob Pike和Russ Cox，以及很多其他Go团队的核心成员多次仔细阅读了本书的手稿，他们对本书的组织结构和表述用词等给出了很多宝贵的建议</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.1. Hello, World</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-01/</guid>
      <description>1.1. Hello, World 我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》（</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.2. 命令行参数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-02/</guid>
      <description>1.2. 命令行参数 大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？一些程序生成自己的数据，但通常</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.3. 查找重复的行</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-03/</guid>
      <description>1.3. 查找重复的行 对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.4. GIF动画</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-04/</guid>
      <description>1.4. GIF动画 下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.5. 获取URL</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-05/</guid>
      <description>1.5. 获取URL 对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。Go语言在net这个强大package的帮助下提供了一系列的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.6. 并发获取多个URL</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-06/</guid>
      <description>1.6. 并发获取多个URL Go语言最有意思并且最新奇的特性就是对并发编程的支持。并发编程是一个大话题，在第八章和第九章中会专门讲到。这里我们只浅尝</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.7. Web服务</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-07/</guid>
      <description>1.7. Web服务 Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 1.8. 本章要点</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1-08/</guid>
      <description>1.8. 本章要点 本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch1- 第一章　入门</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch1/ch1/</guid>
      <description>第一章 入门 本章介绍Go语言的基础组件。本章提供了足够的信息和示例程序，希望可以帮你尽快入门，写出有用的程序。本章和之后章节的示例程序都针对你</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.1. 包简介</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-01/</guid>
      <description>10.1. 包简介 任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.2. 导入路径</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-02/</guid>
      <description>10.2. 导入路径 每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。 import ( &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;encoding/json&amp;quot; &amp;quot;golang.org/x/net/html&amp;quot; &amp;quot;github.com/go-sql-driver/mysql&amp;quot; ) 就像我们在2.6</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.3. 包声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-03/</guid>
      <description>10.3. 包声明 在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。 例如，mat</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.4. 导入声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-04/</guid>
      <description>10.4. 导入声明 可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.5. 包的匿名导入</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-05/</guid>
      <description>10.5. 包的匿名导入 如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.6. 包和命名</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-06/</guid>
      <description>10.6. 包和命名 在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。 当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7. 工具</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07/</guid>
      <description>10.7. 工具 本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。 Go语言的工具箱集合了一系列功</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.1. 工作区结构</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-1/</guid>
      <description>10.7.1. 工作区结构 对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.2. 下载包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-2/</guid>
      <description>10.7.2. 下载包 使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。 使用命令go get可以下载一</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.3. 构建包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-3/</guid>
      <description>10.7.3. 构建包 go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.4. 包文档</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-4/</guid>
      <description>10.7.4. 包文档 Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。 Go语言中的文档注释一般是</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.5. 内部包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-5/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-5/</guid>
      <description>10.7.5. 内部包 在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。 有时候，一</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 10.7.6. 查询包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-6/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10-07-6/</guid>
      <description>10.7.6. 查询包 go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径： $ go list github.com/go-sql-driver/mysql github.com/go-sql-driver/mysql go list命令的参数还可以用</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch10- 第十章　包和工具</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch10/ch10/</guid>
      <description>第十章 包和工具 现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.1. go test</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-01/</guid>
      <description>11.1. go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2. 测试函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02/</guid>
      <description>11.2. 测试函数 每个测试函数必须导入testing包。测试函数有如下的签名： func TestName(t *testing.T) { // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.1. 随机测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-1/</guid>
      <description>11.2.1. 随机测试 表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.2. 测试一个命令</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-2/</guid>
      <description>11.2.2. 测试一个命令 对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.3. 白盒测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-3/</guid>
      <description>11.2.3. 白盒测试 一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.4. 外部测试包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-4/</guid>
      <description>11.2.4. 外部测试包 考虑下这两个包：net/url包，提供了URL解析的功能；net/http包，提供了web服务和HTTP客户端的功能。如我们所料</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.5. 编写有效的测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-5/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-5/</guid>
      <description>11.2.5. 编写有效的测试 许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.2.6. 避免脆弱的测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-6/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-02-6/</guid>
      <description>11.2.6. 避免脆弱的测试 如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.3. 测试覆盖率</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-03/</guid>
      <description>11.3. 测试覆盖率 就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.4. 基准测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-04/</guid>
      <description>11.4. 基准测试 基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.5. 剖析</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-05/</guid>
      <description>11.5. 剖析 基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 11.6. 示例函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11-06/</guid>
      <description>11.6. 示例函数 第三种被go test特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindr</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch11- 第十一章　测试</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch11/ch11/</guid>
      <description>第十一章 测试 Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memo</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.1. 为何需要反射?</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-01/</guid>
      <description>12.1. 为何需要反射? 有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.2. reflect.Type 和 reflect.Value</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-02/</guid>
      <description>12.2. reflect.Type 和 reflect.Value 反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.3. Display，一个递归的值打印器</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-03/</guid>
      <description>12.3. Display，一个递归的值打印器 接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个fmt.Sprint函数，我们只是构</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.4. 示例 编码为S表达式</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-04/</guid>
      <description>12.4. 示例：编码为S表达式 Display是一个用于显示结构化数据的调试工具，但是它并不能将任意的Go语言对象编码为通用消息然后用于进程间通信。 正</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.5. 通过reflect.Value修改值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-05/</guid>
      <description>12.5. 通过reflect.Value修改值 到目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.6. 示例 解码S表达式</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-06/</guid>
      <description>12.6. 示例：解码S表达式 标准库中encoding/&amp;hellip;下每个包中提供的Marshal编码函数都有一个对应的Unmarshal函数用于</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.7. 获取结构体字段标签</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-07/</guid>
      <description>12.7. 获取结构体字段标签 在4.5节我们使用构体成员标签用于设置对应JSON对应的名字。其中json成员标签让我们可以选择成员的名字和抑制零值成员</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.8. 显示一个类型的方法集</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-08/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-08/</guid>
      <description>12.8. 显示一个类型的方法集 我们的最后一个例子是使用reflect.Type来打印任意值的类型和枚举它的方法： gopl.io/ch12/methods // Print prints the method set of the value x. func Print(x interface{}) { v := reflect.ValueOf(x)</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 12.9. 几点忠告</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-09/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12-09/</guid>
      <description>12.9. 几点忠告 虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可以实现哪些功能。反射是一个强大并富有表达力的工</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch12- 第十二章　反射</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch12/ch12/</guid>
      <description>第十二章 反射 Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 13.1. unsafe.Sizeof, Alignof 和 Offsetof</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-01/</guid>
      <description>13.1. unsafe.Sizeof, Alignof 和 Offsetof unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个Size</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 13.2. unsafe.Pointer</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-02/</guid>
      <description>13.2. unsafe.Pointer 大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 13.3. 示例 深度相等判断</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-03/</guid>
      <description>13.3. 示例：深度相等判断 来自reflect包的DeepEqual函数可以对两个值进行深度相等判断。DeepEqual函数使用内建的==比较操作符</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 13.4. 通过cgo调用C代码</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-04/</guid>
      <description>13.4. 通过cgo调用C代码 Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 13.5. 几点忠告</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13-05/</guid>
      <description>13.5. 几点忠告 我们在前一章结尾的时候，我们警告要谨慎使用reflect包。那些警告同样适用于本章的unsafe包。 高级语言使得程序员不用再关心真</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch13- 第十三章　底层编程</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch13/ch13/</guid>
      <description>第十三章 底层编程 Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查可以发现大多数类型不匹配的操作，例如两个字</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.1. 命名</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-01/</guid>
      <description>2.1. 命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicod</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.2. 声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-02/</guid>
      <description>2.2. 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.3. 变量</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03/</guid>
      <description>2.3. 变量 var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下： var 变量名字 类型 = 表达式</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.3.1. 简短变量声明</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-1/</guid>
      <description>2.3.1. 简短变量声明 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.3.2. 指针</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-2/</guid>
      <description>2.3.2. 指针 一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.3.3. new函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-3/</guid>
      <description>2.3.3. new函数 另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.3.4. 变量的生命周期</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-03-4/</guid>
      <description>2.3.4. 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.4. 赋值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04/</guid>
      <description>2.4. 赋值 使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。 x = 1 // 命名变量的赋值 *p =</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.4.1. 元组赋值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04-1/</guid>
      <description>2.4.1. 元组赋值 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.4.2. 可赋值性</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-04-2/</guid>
      <description>2.4.2. 可赋值性 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.5. 类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-05/</guid>
      <description>2.5. 类型 变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.6. 包和文件</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06/</guid>
      <description>2.6. 包和文件 Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.6.1. 导入包</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06-1/</guid>
      <description>2.6.1. 导入包 在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似&amp;rdquo;gopl.io/ch2/tempconv&amp;rdquo</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.6.2. 包的初始化</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-06-2/</guid>
      <description>2.6.2. 包的初始化 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化： var a = b + c // a 第三个初始化, 为 3 var b = f() // b</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 2.7. 作用域</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-07/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2-07/</guid>
      <description>2.7. 作用域 一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。 不要将作用</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch2- 第二章　程序结构</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch2/ch2/</guid>
      <description>第二章 程序结构 Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.1. 整型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-01/</guid>
      <description>3.1. 整型 Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。让我们先从整数类型开始介</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.2. 浮点数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-02/</guid>
      <description>3.2. 浮点数 Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.3. 复数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-03/</guid>
      <description>3.3. 复数 Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.4. 布尔型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-04/</guid>
      <description>3.4. 布尔型 一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和&amp;lt;等比较操作也会产生布尔</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5. 字符串</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05/</guid>
      <description>3.5. 字符串 一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5.1. 字符串面值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-1/</guid>
      <description>3.5.1. 字符串面值 字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可： &amp;quot;Hello, 世界&amp;quot; 因为Go语言源文件总是用UTF8编</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5.2. Unicode</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-2/</guid>
      <description>3.5.2. Unicode 在很久以前，世界还是比较简单的，起码计算机世界就只有一个ASCII字符集：美国信息交换标准代码。ASCII，更准确地说是美国的ASCII</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5.3. UTF-8</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-3/</guid>
      <description>3.5.3. UTF-8 UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5.4. 字符串和Byte切片</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-4/</guid>
      <description>3.5.4. 字符串和Byte切片 标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.5.5. 字符串和数字的转换</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-5/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-05-5/</guid>
      <description>3.5.5. 字符串和数字的转换 除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。 将一个整数转为字</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.6. 常量</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06/</guid>
      <description>3.6. 常量 常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。 一个常量的声明语句定义</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.6.1. iota 常量生成器</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06-1/</guid>
      <description>3.6.1. iota 常量生成器 常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个con</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 3.6.2. 无类型常量</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3-06-2/</guid>
      <description>3.6.2. 无类型常量 Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Dur</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch3- 第三章　基础数据类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch3/ch3/</guid>
      <description>第三章 基础数据类型 虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.1. 数组</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-01/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-01/</guid>
      <description>4.1. 数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.2. Slice</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02/</guid>
      <description>4.2. Slice Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；sl</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.2.1. append函数</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02-1/</guid>
      <description>4.2.1. append函数 内置的append函数用于向slice追加元素： var runes []rune for _, r := range &amp;quot;Hello, 世界&amp;quot; { runes = append(runes, r) } fmt.Printf(&amp;quot;%q\n&amp;quot;, runes) // &amp;quot;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; &#39; &#39; &#39;世&#39;</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.2.2. Slice内存技巧</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-02-2/</guid>
      <description>4.2.2. Slice内存技巧 让我们看看更多的例子，比如旋转slice、反转slice或在slice原有内存空间修改元素。给定一个字符串列表，下面的n</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.3. Map</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-03/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-03/</guid>
      <description>4.3. Map 哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.4. 结构体</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04/</guid>
      <description>4.4. 结构体 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。用结构体的经典案例是处理公司的员工信息，</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.4.1. 结构体字面值</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-1/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-1/</guid>
      <description>4.4.1. 结构体字面值 结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。 type Point struct{ X, Y int } p := Point{1, 2} 这里有两种形式的结构体字面值语法，上</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.4.2. 结构体比较</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-2/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-2/</guid>
      <description>4.4.2. 结构体比较 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.4.3. 结构体嵌入和匿名成员</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-3/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-04-3/</guid>
      <description>4.4.3. 结构体嵌入和匿名成员 在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.5. JSON</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-05/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-05/</guid>
      <description>4.5. JSON JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 X</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 4.6. 文本和HTML模板</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-06/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4-06/</guid>
      <description>4.6. 文本和HTML模板 前面的例子，只是最简单的格式化，使用Printf是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码</description>
    </item>
    
    <item>
      <title>golang入门圣经 ch4- 第四章　复合数据类型</title>
      <link>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4/</link>
      <pubDate>Sun, 20 Oct 2019 22:37:27 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/golang/20191020/ch4/ch4/</guid>
      <description>第四章 复合数据类型 在第三章我们讨论了基本数据类型，它们可以用于构建程序中数据的结构，是Go语言世界的原子。在本章，我们将讨论复合数据类型，它</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson0- 搭建 Node.js 开发环境</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson0/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson0/readme/</guid>
      <description>《搭建 Node.js 开发环境》 本课程假设大家都是在 Linux 或者 Mac 下面。至于使用 Windows 并坚持玩新技术的同学，我坚信他们一定有着过人的、甚至是不可告人的兼容性 bug 处理能</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson1- 一个最简单的 express 应用</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson1/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson1/readme/</guid>
      <description>《一个最简单的 express 应用》 目标 建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 http://localhost:3000/ 时，输出 Hello World。 挑战 访问 http://localhost:3000/ 时，输出 你好，世界。 知识点 包管理</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson10- benchmark 怎么写</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson10/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson10/readme/</guid>
      <description>《benchmark 怎么写》 目标 有一个字符串 var number = &#39;100&#39;，我们要将它转换成 Number 类型的 100。 目前有三个选项：+, parseInt, Number 请测试哪个方法更快。 知</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson11- 作用域与闭包：this，var，(function () {})</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson11/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson11/readme/</guid>
      <description>《作用域与闭包：this，var，(function () {})》 目标 无具体目标 知识点 理解 js 中 var 的作用域 了解闭包的概念 理解 this 的指向 课程内容 es6</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson12- 线上部署：heroku</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson12/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson12/readme/</guid>
      <description>《线上部署：heroku》 目标 将 https://github.com/Ricardo-Li/node-practice-2 (这个项目已经被删了。参照 https://github.com/alsotang/node-lessons/tree/master/lesson3 的代码自己操作一下吧。)这个项目部署上 heroku，成为一个线上项目 我部署的在</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson13- 持续集成平台：travis</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson13/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson13/readme/</guid>
      <description>《持续集成平台：travis》 目标 无明确目标 知识点 学习使用 travis-ci 对项目进行持续集成测试 (https://travis-ci.org/ ) 课程内容 首先来看看这个项目：https://githu</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson14- js 中的那些最佳实践</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson14/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson14/readme/</guid>
      <description>《js 中的那些最佳实践》 这个章节需要大家帮忙补充，一次性想不完那么多 JavaScript 语言精粹 http://book.douban.com/subject/3590768/ 这本书很薄，只有 155 页，但该讲的几乎都讲了。大家想办法搞来看看</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson15- Mongodb 与 Mongoose 的使用</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson15/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson15/readme/</guid>
      <description>《Mongodb 与 Mongoose 的使用》 目标 无明确目标 知识点 了解 mongodb (http://www.mongodb.org/ ) 学习 mongoose 的使用 (http://mongoosejs.com/ ) 课程内容 mongodb mongodb 这个名词相信大家不会陌生吧。有段时间 nosql 的概念炒得特别火</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson16- cookie 和 session</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson16/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson16/readme/</guid>
      <description>cookie 和 session 众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson17- 使用 promise 替代回调函数</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson17/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson17/readme/</guid>
      <description>《使用 promise 替代回调函数》 知识点 理解 Promise 概念，为什么需要 promise 学习 q 的 API，利用 q 来替代回调函数(https://github.com/krisko</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson18- 何为 connect 中间件</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson18/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson18/readme/</guid>
      <description>《何为 connect 中间件》 目标 理解中间件的概念 了解 Connect 的实现 课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介 这是从 httpServer 到 Express 的升级过程。 HTTP Nodejs 的经典 httpServer 代码 var http =</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson2- 学习使用外部模块</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson2/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson2/readme/</guid>
      <description>《学习使用外部模块》 目标 建立一个 lesson2 项目，在其中编写代码。 当在浏览器中访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 md5 值，即 bdd5e57b5c0040f9dc23d43</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson3- 使用 superagent 与 cheerio 完成简单爬虫</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson3/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson3/readme/</guid>
      <description>《使用 superagent 与 cheerio 完成简单爬虫》 目标 建立一个 lesson3 项目，在其中编写代码。 当在浏览器中访问 http://localhost:3000/ 时，输出 CNode(https://cnodejs.org/ ) 社区首页的所有帖子标题和链接，以 json 的形式。 输出示</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson4- 使用 eventproxy 控制并发</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson4/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson4/readme/</guid>
      <description>《使用 eventproxy 控制并发》 目标 建立一个 lesson4 项目，在其中编写代码。 代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson5- 使用 async 控制并发</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson5/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson5/readme/</guid>
      <description>《使用 async 控制并发》 目标 建立一个 lesson5 项目，在其中编写代码。 代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson6- 测试用例：mocha，should，istanbul</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson6/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson6/readme/</guid>
      <description>《测试用例：mocha，should，istanbul》 目标 建立一个 lesson6 项目，在其中编写代码。 main.js: 其中有个 fibonacci 函数。fibonacci 的介绍见：h</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson7- 浏览器端测试：mocha，chai，phantomjs</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson7/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson7/readme/</guid>
      <description>《浏览器端测试：mocha，chai，phantomjs》 目标 建立一个 lesson7 项目，在其中编写代码，我们暂时命名为 vendor 根据下面的步骤，最终的项目结构</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson8- 测试用例：supertest</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson8/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson8/readme/</guid>
      <description>《测试用例：supertest》 目标 建立一个 lesson8 项目，在其中编写代码。 app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：http://en.wik</description>
    </item>
    
    <item>
      <title>从零开始nodejs lesson9- 正则表达式</title>
      <link>https://blog.zshipu.com/article/post/nodejs/lesson9/readme/</link>
      <pubDate>Sun, 20 Oct 2019 20:32:12 +0800</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/nodejs/lesson9/readme/</guid>
      <description>《正则表达式》 目标 var web_development = &amp;quot;python php ruby javascript jsonp perhapsphpisoutdated&amp;quot;; 找出其中 包含 p 但不包含 ph 的所有单词，即 [ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ] 知识点 正则表达式的使用 js 中的正则表达式与 pcre(http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions ) 的区别 课程内</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/practice/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/qdvanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/post/docker/20191111/kubernetes/qdvanced/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>